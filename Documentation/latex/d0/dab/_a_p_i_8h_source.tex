\subsection{A\+P\+I.\+h}
\label{_a_p_i_8h_source}\index{include/\+A\+P\+I.\+h@{include/\+A\+P\+I.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/** @file API.h}
00002 \textcolor{comment}{ * @brief Provides the high-level user functionality intended for use by typical VEX Cortex}
00003 \textcolor{comment}{ * programmers.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * This file should be included for you in the predefined stubs in each new VEX Cortex PROS}
00006 \textcolor{comment}{ * project through the inclusion of "main.h". In any new C source file, it is advisable to}
00007 \textcolor{comment}{ * include main.h instead of referencing API.h by name, to better handle any nomenclature}
00008 \textcolor{comment}{ * changes to this file or its contents.}
00009 \textcolor{comment}{ *}
00010 \textcolor{comment}{ * Copyright (c) 2011-2016, Purdue University ACM SIGBots.}
00011 \textcolor{comment}{ * All rights reserved.}
00012 \textcolor{comment}{ *}
00013 \textcolor{comment}{ * This Source Code Form is subject to the terms of the Mozilla Public}
00014 \textcolor{comment}{ * License, v. 2.0. If a copy of the MPL was not distributed with this}
00015 \textcolor{comment}{ * file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * PROS contains FreeRTOS (http://www.freertos.org) whose source code may be}
00018 \textcolor{comment}{ * obtained from http://sourceforge.net/projects/freertos/files/ or on request.}
00019 \textcolor{comment}{ */}
00020 
00021 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{API\_H\_}
00022 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{API\_H\_}
00023 
00024 \textcolor{comment}{// System includes}
00025 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00026 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdbool}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00027 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdarg}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00028 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdint}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00029 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00030 
00031 \textcolor{comment}{// Begin C++ extern to C}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \_\_cplusplus
00033 \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \{
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00035 
00036 \textcolor{comment}{// -------------------- VEX competition functions --------------------}
00037 
00038 \textcolor{comment}{/**}
00039 \textcolor{comment}{ * DOWN button (valid on channels 5, 6, 7, 8)}
00040 \textcolor{comment}{ */}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{JOY\_DOWN} 1
00042 \textcolor{comment}{/**}
00043 \textcolor{comment}{ * LEFT button (valid on channels 7, 8)}
00044 \textcolor{comment}{ */}
00045 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{JOY\_LEFT} 2
00046 \textcolor{comment}{/**}
00047 \textcolor{comment}{ * UP button (valid on channels 5, 6, 7, 8)}
00048 \textcolor{comment}{ */}
00049 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{JOY\_UP} 4
00050 \textcolor{comment}{/**}
00051 \textcolor{comment}{ * RIGHT button (valid on channels 7, 8)}
00052 \textcolor{comment}{ */}
00053 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{JOY\_RIGHT} 8
00054 \textcolor{comment}{/**}
00055 \textcolor{comment}{ * Analog axis for the X acceleration from the VEX Joystick.}
00056 \textcolor{comment}{ */}
00057 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ACCEL\_X} 5
00058 \textcolor{comment}{/**}
00059 \textcolor{comment}{ * Analog axis for the Y acceleration from the VEX Joystick.}
00060 \textcolor{comment}{ */}
00061 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ACCEL\_Y} 6
00062 
00063 \textcolor{comment}{/**}
00064 \textcolor{comment}{ * Returns true if the robot is in autonomous mode, or false otherwise.}
00065 \textcolor{comment}{ *}
00066 \textcolor{comment}{ * While in autonomous mode, joystick inputs will return a neutral value, but serial port}
00067 \textcolor{comment}{ * communications (even over VexNET) will still work properly.}
00068 \textcolor{comment}{ */}
00069 \textcolor{keywordtype}{bool} isAutonomous();
00070 \textcolor{comment}{/**}
00071 \textcolor{comment}{ * Returns true if the robot is enabled, or false otherwise.}
00072 \textcolor{comment}{ *}
00073 \textcolor{comment}{ * While disabled via the VEX Competition Switch or VEX Field Controller, motors will not}
00074 \textcolor{comment}{ * function. However, the digital I/O ports can still be changed, which may indirectly affect}
00075 \textcolor{comment}{ * the robot state (e.g. solenoids). Avoid performing externally visible actions while}
00076 \textcolor{comment}{ * disabled (the kernel should take care of this most of the time).}
00077 \textcolor{comment}{ */}
00078 \textcolor{keywordtype}{bool} isEnabled();
00079 \textcolor{comment}{/**}
00080 \textcolor{comment}{ * Returns true if a joystick is connected to the specified slot number (1 or 2), or false}
00081 \textcolor{comment}{ * otherwise.}
00082 \textcolor{comment}{ *}
00083 \textcolor{comment}{ * Useful for automatically merging joysticks for one operator, or splitting for two. This}
00084 \textcolor{comment}{ * function does not work properly during initialize() or initializeIO() and can return false}
00085 \textcolor{comment}{ * positives. It should be checked once and stored at the beginning of operatorControl().}
00086 \textcolor{comment}{ *}
00087 \textcolor{comment}{ * @param joystick the joystick slot to check}
00088 \textcolor{comment}{ */}
00089 \textcolor{keywordtype}{bool} isJoystickConnected(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} joystick);
00090 \textcolor{comment}{/**}
00091 \textcolor{comment}{ * Returns true if a VEX field controller or competition switch is connected, or false}
00092 \textcolor{comment}{ * otherwise.}
00093 \textcolor{comment}{ *}
00094 \textcolor{comment}{ * When in online mode, the switching between autonomous() and operatorControl() tasks is}
00095 \textcolor{comment}{ * managed by the PROS kernel.}
00096 \textcolor{comment}{ */}
00097 \textcolor{keywordtype}{bool} isOnline();
00098 \textcolor{comment}{/**}
00099 \textcolor{comment}{ * Gets the value of a control axis on the VEX joystick. Returns the value from -127 to 127,}
00100 \textcolor{comment}{ * or 0 if no joystick is connected to the requested slot.}
00101 \textcolor{comment}{ *}
00102 \textcolor{comment}{ * @param joystick the joystick slot to check}
00103 \textcolor{comment}{ * @param axis one of 1, 2, 3, 4, ACCEL\_X, or ACCEL\_Y}
00104 \textcolor{comment}{ */}
00105 \textcolor{keywordtype}{int} joystickGetAnalog(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} joystick, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} axis);
00106 \textcolor{comment}{/**}
00107 \textcolor{comment}{ * Gets the value of a button on the VEX joystick. Returns true if that button is pressed, or}
00108 \textcolor{comment}{ * false otherwise. If no joystick is connected to the requested slot, returns false.}
00109 \textcolor{comment}{ *}
00110 \textcolor{comment}{ * @param joystick the joystick slot to check}
00111 \textcolor{comment}{ * @param buttonGroup one of 5, 6, 7, or 8 to request that button as labelled on the joystick}
00112 \textcolor{comment}{ * @param button one of JOY\_UP, JOY\_DOWN, JOY\_LEFT, or JOY\_RIGHT; requesting JOY\_LEFT or}
00113 \textcolor{comment}{ * JOY\_RIGHT for groups 5 or 6 will cause an undefined value to be returned}
00114 \textcolor{comment}{ */}
00115 \textcolor{keywordtype}{bool} joystickGetDigital(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} joystick, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buttonGroup,
00116        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} button);
00117 \textcolor{comment}{/**}
00118 \textcolor{comment}{ * Returns the backup battery voltage in millivolts.}
00119 \textcolor{comment}{ *}
00120 \textcolor{comment}{ * If no backup battery is connected, returns 0.}
00121 \textcolor{comment}{ */}
00122 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} powerLevelBackup();
00123 \textcolor{comment}{/**}
00124 \textcolor{comment}{ * Returns the main battery voltage in millivolts.}
00125 \textcolor{comment}{ *}
00126 \textcolor{comment}{ * In rare circumstances, this method might return 0. Check the output value for reasonability}
00127 \textcolor{comment}{ * before blindly blasting the user.}
00128 \textcolor{comment}{ */}
00129 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} powerLevelMain();
00130 \textcolor{comment}{/**}
00131 \textcolor{comment}{ * Sets the team name displayed to the VEX field control and VEX Firmware Upgrade.}
00132 \textcolor{comment}{ *}
00133 \textcolor{comment}{ * @param name a string containing the team name; only the first eight characters will be shown}
00134 \textcolor{comment}{ */}
00135 \textcolor{keywordtype}{void} setTeamName(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name);
00136 
00137 \textcolor{comment}{// -------------------- Pin control functions --------------------}
00138 
00139 \textcolor{comment}{/**}
00140 \textcolor{comment}{ * There are 8 available analog I/O on the Cortex.}
00141 \textcolor{comment}{ */}
00142 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{BOARD\_NR\_ADC\_PINS} 8
00143 \textcolor{comment}{/**}
00144 \textcolor{comment}{ * There are 27 available I/O on the Cortex that can be used for digital communication.}
00145 \textcolor{comment}{ *}
00146 \textcolor{comment}{ * This excludes the crystal ports but includes the Communications, Speaker, and Analog ports.}
00147 \textcolor{comment}{ *}
00148 \textcolor{comment}{ * The motor ports are not on the Cortex and are thus excluded from this count. Pin 0 is the}
00149 \textcolor{comment}{ * Speaker port, pins 1-12 are the standard Digital I/O, 13-20 are the Analog I/O, 21+22 are}
00150 \textcolor{comment}{ * UART1, 23+24 are UART2, and 25+26 are the I2C port.}
00151 \textcolor{comment}{ */}
00152 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{BOARD\_NR\_GPIO\_PINS} 27
00153 \textcolor{comment}{/**}
00154 \textcolor{comment}{ * Used for digitalWrite() to specify a logic HIGH state to output.}
00155 \textcolor{comment}{ *}
00156 \textcolor{comment}{ * In reality, using any non-zero expression or "true" will work to set a pin to HIGH.}
00157 \textcolor{comment}{ */}
00158 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{HIGH} 1
00159 \textcolor{comment}{/**}
00160 \textcolor{comment}{ * Used for digitalWrite() to specify a logic LOW state to output.}
00161 \textcolor{comment}{ *}
00162 \textcolor{comment}{ * In reality, using a zero expression or "false" will work to set a pin to LOW.}
00163 \textcolor{comment}{ */}
00164 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LOW} 0
00165 
00166 \textcolor{comment}{/**}
00167 \textcolor{comment}{ * pinMode() state for digital input, with pullup.}
00168 \textcolor{comment}{ *}
00169 \textcolor{comment}{ * This is the default state for the 12 Digital pins. The pullup causes the input to read as}
00170 \textcolor{comment}{ * "HIGH" when unplugged, but is fairly weak and can safely be driven by most sources. Many VEX}
00171 \textcolor{comment}{ * digital sensors rely on this behavior and cannot be used with INPUT\_FLOATING.}
00172 \textcolor{comment}{ */}
00173 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INPUT} 0x0A
00174 \textcolor{comment}{/**}
00175 \textcolor{comment}{ * pinMode() state for analog inputs.}
00176 \textcolor{comment}{ *}
00177 \textcolor{comment}{ * This is the default state for the 8 Analog pins and the Speaker port. This only works on}
00178 \textcolor{comment}{ * pins with analog input capabilities; use anywhere else results in undefined behavior.}
00179 \textcolor{comment}{ */}
00180 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INPUT\_ANALOG} 0x00
00181 \textcolor{comment}{/**}
00182 \textcolor{comment}{ * pinMode() state for digital input, without pullup.}
00183 \textcolor{comment}{ *}
00184 \textcolor{comment}{ * Beware of power consumption, as digital inputs left "floating" may switch back and forth}
00185 \textcolor{comment}{ * and cause spurious interrupts.}
00186 \textcolor{comment}{ */}
00187 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INPUT\_FLOATING} 0x04
00188 \textcolor{comment}{/**}
00189 \textcolor{comment}{ * pinMode() state for digital output, push-pull.}
00190 \textcolor{comment}{ *}
00191 \textcolor{comment}{ * This is the mode which should be used to output a digital HIGH or LOW value from the Cortex.}
00192 \textcolor{comment}{ * This mode is useful for pneumatic solenoid valves and VEX LEDs.}
00193 \textcolor{comment}{ */}
00194 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OUTPUT} 0x01
00195 \textcolor{comment}{/**}
00196 \textcolor{comment}{ * pinMode() state for open-drain outputs.}
00197 \textcolor{comment}{ *}
00198 \textcolor{comment}{ * This is useful in a few cases for external electronics and should not be used for the VEX}
00199 \textcolor{comment}{ * solenoid or LEDs.}
00200 \textcolor{comment}{ */}
00201 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OUTPUT\_OD} 0x05
00202 
00203 \textcolor{comment}{/**}
00204 \textcolor{comment}{ * Calibrates the analog sensor on the specified channel.}
00205 \textcolor{comment}{ *}
00206 \textcolor{comment}{ * This method assumes that the true sensor value is not actively changing at this time and}
00207 \textcolor{comment}{ * computes an average from approximately 500 samples, 1 ms apart, for a 0.5 s period of}
00208 \textcolor{comment}{ * calibration. The average value thus calculated is returned and stored for later calls to the}
00209 \textcolor{comment}{ * analogReadCalibrated() and analogReadCalibratedHR() functions. These functions will return}
00210 \textcolor{comment}{ * the difference between this value and the current sensor value when called.}
00211 \textcolor{comment}{ *}
00212 \textcolor{comment}{ * Do not use this function in initializeIO(), or when the sensor value might be unstable}
00213 \textcolor{comment}{ * (gyro rotation, accelerometer movement).}
00214 \textcolor{comment}{ *}
00215 \textcolor{comment}{ * This function may not work properly if the VEX Cortex is tethered to a PC using the orange}
00216 \textcolor{comment}{ * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery}
00217 \textcolor{comment}{ * provides power to sensors.}
00218 \textcolor{comment}{ *}
00219 \textcolor{comment}{ * @param channel the channel to calibrate from 1-8}
00220 \textcolor{comment}{ * @return the average sensor value computed by this function}
00221 \textcolor{comment}{ */}
00222 \textcolor{keywordtype}{int} analogCalibrate(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} channel);
00223 \textcolor{comment}{/**}
00224 \textcolor{comment}{ * Reads an analog input channel and returns the 12-bit value.}
00225 \textcolor{comment}{ *}
00226 \textcolor{comment}{ * The value returned is undefined if the analog pin has been switched to a different mode.}
00227 \textcolor{comment}{ * This function is Wiring-compatible with the exception of the larger output range. The}
00228 \textcolor{comment}{ * meaning of the returned value varies depending on the sensor attached.}
00229 \textcolor{comment}{ *}
00230 \textcolor{comment}{ * This function may not work properly if the VEX Cortex is tethered to a PC using the orange}
00231 \textcolor{comment}{ * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery}
00232 \textcolor{comment}{ * provides power to sensors.}
00233 \textcolor{comment}{ *}
00234 \textcolor{comment}{ * @param channel the channel to read from 1-8}
00235 \textcolor{comment}{ * @return the analog sensor value, where a value of 0 reflects an input voltage of nearly 0 V}
00236 \textcolor{comment}{ * and a value of 4095 reflects an input voltage of nearly 5 V}
00237 \textcolor{comment}{ */}
00238 \textcolor{keywordtype}{int} analogRead(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} channel);
00239 \textcolor{comment}{/**}
00240 \textcolor{comment}{ * Reads the calibrated value of an analog input channel.}
00241 \textcolor{comment}{ *}
00242 \textcolor{comment}{ * The analogCalibrate() function must be run first on that channel. This function is}
00243 \textcolor{comment}{ * inappropriate for sensor values intended for integration, as round-off error can accumulate}
00244 \textcolor{comment}{ * causing drift over time. Use analogReadCalibratedHR() instead.}
00245 \textcolor{comment}{ *}
00246 \textcolor{comment}{ * This function may not work properly if the VEX Cortex is tethered to a PC using the orange}
00247 \textcolor{comment}{ * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery}
00248 \textcolor{comment}{ * provides power to sensors.}
00249 \textcolor{comment}{ *}
00250 \textcolor{comment}{ * @param channel the channel to read from 1-8}
00251 \textcolor{comment}{ * @return the difference of the sensor value from its calibrated default from -4095 to 4095}
00252 \textcolor{comment}{ */}
00253 \textcolor{keywordtype}{int} analogReadCalibrated(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} channel);
00254 \textcolor{comment}{/**}
00255 \textcolor{comment}{ * Reads the calibrated value of an analog input channel 1-8 with enhanced precision.}
00256 \textcolor{comment}{ *}
00257 \textcolor{comment}{ * The analogCalibrate() function must be run first. This is intended for integrated sensor}
00258 \textcolor{comment}{ * values such as gyros and accelerometers to reduce drift due to round-off, and should not be}
00259 \textcolor{comment}{ * used on a sensor such as a line tracker or potentiometer.}
00260 \textcolor{comment}{ *}
00261 \textcolor{comment}{ * The value returned actually has 16 bits of "precision", even though the ADC only reads}
00262 \textcolor{comment}{ * 12 bits, so that errors induced by the average value being between two values come out}
00263 \textcolor{comment}{ * in the wash when integrated over time. Think of the value as the true value times 16.}
00264 \textcolor{comment}{ *}
00265 \textcolor{comment}{ * This function may not work properly if the VEX Cortex is tethered to a PC using the orange}
00266 \textcolor{comment}{ * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery}
00267 \textcolor{comment}{ * provides power to sensors.}
00268 \textcolor{comment}{ *}
00269 \textcolor{comment}{ * @param channel the channel to read from 1-8}
00270 \textcolor{comment}{ * @return the difference of the sensor value from its calibrated default from -16384 to 16384}
00271 \textcolor{comment}{ */}
00272 \textcolor{keywordtype}{int} analogReadCalibratedHR(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} channel);
00273 \textcolor{comment}{/**}
00274 \textcolor{comment}{ * Gets the digital value (1 or 0) of a pin configured as a digital input.}
00275 \textcolor{comment}{ *}
00276 \textcolor{comment}{ * If the pin is configured as some other mode, the digital value which reflects the current}
00277 \textcolor{comment}{ * state of the pin is returned, which may or may not differ from the currently set value. The}
00278 \textcolor{comment}{ * return value is undefined for pins configured as Analog inputs, or for ports in use by a}
00279 \textcolor{comment}{ * Communications interface. This function is Wiring-compatible.}
00280 \textcolor{comment}{ *}
00281 \textcolor{comment}{ * This function may not work properly if the VEX Cortex is tethered to a PC using the orange}
00282 \textcolor{comment}{ * USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery}
00283 \textcolor{comment}{ * provides power to sensors.}
00284 \textcolor{comment}{ *}
00285 \textcolor{comment}{ * @param pin the pin to read from 1-26}
00286 \textcolor{comment}{ * @return true if the pin is HIGH, or false if it is LOW}
00287 \textcolor{comment}{ */}
00288 \textcolor{keywordtype}{bool} digitalRead(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} pin);
00289 \textcolor{comment}{/**}
00290 \textcolor{comment}{ * Sets the digital value (1 or 0) of a pin configured as a digital output.}
00291 \textcolor{comment}{ *}
00292 \textcolor{comment}{ * If the pin is configured as some other mode, behavior is undefined. This function is}
00293 \textcolor{comment}{ * Wiring-compatible.}
00294 \textcolor{comment}{ *}
00295 \textcolor{comment}{ * @param pin the pin to write from 1-26}
00296 \textcolor{comment}{ * @param value an expression evaluating to "true" or "false" to set the output to HIGH or LOW}
00297 \textcolor{comment}{ * respectively, or the constants HIGH or LOW themselves}
00298 \textcolor{comment}{ */}
00299 \textcolor{keywordtype}{void} digitalWrite(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} pin, \textcolor{keywordtype}{bool} value);
00300 \textcolor{comment}{/**}
00301 \textcolor{comment}{ * Configures the pin as an input or output with a variety of settings.}
00302 \textcolor{comment}{ *}
00303 \textcolor{comment}{ * Do note that INPUT by default turns on the pull-up resistor, as most VEX sensors are}
00304 \textcolor{comment}{ * open-drain active low. It should not be a big deal for most push-pull sources. This function}
00305 \textcolor{comment}{ * is Wiring-compatible.}
00306 \textcolor{comment}{ *}
00307 \textcolor{comment}{ * @param pin the pin to modify from 1-26}
00308 \textcolor{comment}{ * @param mode one of INPUT, INPUT\_ANALOG, INPUT\_FLOATING, OUTPUT, or OUTPUT\_OD}
00309 \textcolor{comment}{ */}
00310 \textcolor{keywordtype}{void} pinMode(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} pin, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} mode);
00311 
00312 \textcolor{comment}{/*}
00313 \textcolor{comment}{ * Digital port 10 cannot be used as an interrupt port, or for an encoder. Plan accordingly.}
00314 \textcolor{comment}{ */}
00315 
00316 \textcolor{comment}{/**}
00317 \textcolor{comment}{ * When used in ioSetInterrupt(), triggers an interrupt on rising edges (LOW to HIGH).}
00318 \textcolor{comment}{ */}
00319 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INTERRUPT\_EDGE\_RISING} 1
00320 \textcolor{comment}{/**}
00321 \textcolor{comment}{ * When used in ioSetInterrupt(), triggers an interrupt on falling edges (HIGH to LOW).}
00322 \textcolor{comment}{ */}
00323 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INTERRUPT\_EDGE\_FALLING} 2
00324 \textcolor{comment}{/**}
00325 \textcolor{comment}{ * When used in ioSetInterrupt(), triggers an interrupt on both rising and falling edges}
00326 \textcolor{comment}{ * (LOW to HIGH or HIGH to LOW).}
00327 \textcolor{comment}{ */}
00328 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INTERRUPT\_EDGE\_BOTH} 3
00329 \textcolor{comment}{/**}
00330 \textcolor{comment}{ * Type definition for interrupt handlers. Such functions must accept one argument indicating}
00331 \textcolor{comment}{ * the pin which changed.}
00332 \textcolor{comment}{ */}
00333 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} (*InterruptHandler)(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} pin);
00334 
00335 \textcolor{comment}{/**}
00336 \textcolor{comment}{ * Disables interrupts on the specified pin.}
00337 \textcolor{comment}{ *}
00338 \textcolor{comment}{ * Disabling interrupts on interrupt pins which are not in use conserves processing time.}
00339 \textcolor{comment}{ *}
00340 \textcolor{comment}{ * @param pin the pin on which to reset interrupts from 1-9,11-12}
00341 \textcolor{comment}{ */}
00342 \textcolor{keywordtype}{void} ioClearInterrupt(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} pin);
00343 \textcolor{comment}{/**}
00344 \textcolor{comment}{ * Sets up an interrupt to occur on the specified pin, and resets any counters or timers}
00345 \textcolor{comment}{ * associated with the pin.}
00346 \textcolor{comment}{ *}
00347 \textcolor{comment}{ * Each time the specified change occurs, the function pointer passed in will be called with}
00348 \textcolor{comment}{ * the pin that changed as an argument. Enabling pin-change interrupts consumes processing}
00349 \textcolor{comment}{ * time, so it is best to only enable necessary interrupts and to keep the InterruptHandler}
00350 \textcolor{comment}{ * function short. Pin change interrupts can only be enabled on pins 1-9 and 11-12.}
00351 \textcolor{comment}{ *}
00352 \textcolor{comment}{ * Do not use API functions such as delay() inside the handler function, as the function will}
00353 \textcolor{comment}{ * run in an ISR where the scheduler is paused and no other interrupts can execute. It is best}
00354 \textcolor{comment}{ * to quickly update some state and allow a task to perform the work.}
00355 \textcolor{comment}{ *}
00356 \textcolor{comment}{ * Do not use this function on pins that are also being used by the built-in ultrasonic or}
00357 \textcolor{comment}{ * shaft encoder drivers, or on pins which have been switched to output mode.}
00358 \textcolor{comment}{ *}
00359 \textcolor{comment}{ * @param pin the pin on which to enable interrupts from 1-9,11-12}
00360 \textcolor{comment}{ * @param edges one of INTERRUPT\_EDGE\_RISING, INTERRUPT\_EDGE\_FALLING, or INTERRUPT\_EDGE\_BOTH}
00361 \textcolor{comment}{ * @param handler the function to call when the condition is satisfied}
00362 \textcolor{comment}{ */}
00363 \textcolor{keywordtype}{void} ioSetInterrupt(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} pin, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} edges, 
      InterruptHandler handler);
00364 
00365 \textcolor{comment}{// -------------------- Physical output control functions --------------------}
00366 
00367 \textcolor{comment}{/**}
00368 \textcolor{comment}{ * Gets the last set speed of the specified motor channel.}
00369 \textcolor{comment}{ *}
00370 \textcolor{comment}{ * This speed may have been set by any task or the PROS kernel itself. This is not guaranteed}
00371 \textcolor{comment}{ * to be the speed that the motor is actually running at, or even the speed currently being}
00372 \textcolor{comment}{ * sent to the motor, due to latency in the Motor Controller 29 protocol and physical loading.}
00373 \textcolor{comment}{ * To measure actual motor shaft revolution speed, attach a VEX Integrated Motor Encoder or}
00374 \textcolor{comment}{ * VEX Quadrature Encoder and use the velocity functions associated with each.}
00375 \textcolor{comment}{ *}
00376 \textcolor{comment}{ * @param channel the motor channel to fetch from 1-10}
00377 \textcolor{comment}{ * @return the speed last sent to this channel; -127 is full reverse and 127 is full forward,}
00378 \textcolor{comment}{ * with 0 being off}
00379 \textcolor{comment}{ */}
00380 \textcolor{keywordtype}{int} motorGet(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} channel);
00381 \textcolor{comment}{/**}
00382 \textcolor{comment}{ * Sets the speed of the specified motor channel.}
00383 \textcolor{comment}{ *}
00384 \textcolor{comment}{ * Do not use motorSet() with the same channel argument from two different tasks. It is safe to}
00385 \textcolor{comment}{ * use motorSet() with different channel arguments from different tasks.}
00386 \textcolor{comment}{ *}
00387 \textcolor{comment}{ * @param channel the motor channel to modify from 1-10}
00388 \textcolor{comment}{ * @param speed the new signed speed; -127 is full reverse and 127 is full forward, with 0}
00389 \textcolor{comment}{ * being off}
00390 \textcolor{comment}{ */}
00391 \textcolor{keywordtype}{void} motorSet(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} channel, \textcolor{keywordtype}{int} speed);
00392 \textcolor{comment}{/**}
00393 \textcolor{comment}{ * Stops the motor on the specified channel, equivalent to calling motorSet() with an argument}
00394 \textcolor{comment}{ * of zero.}
00395 \textcolor{comment}{ *}
00396 \textcolor{comment}{ * This performs a coasting stop, not an active brake. Since motorStop is similar to}
00397 \textcolor{comment}{ * motorSet(0), see the note for motorSet() about use from multiple tasks.}
00398 \textcolor{comment}{ *}
00399 \textcolor{comment}{ * @param channel the motor channel to stop from 1-10}
00400 \textcolor{comment}{ */}
00401 \textcolor{keywordtype}{void} motorStop(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} channel);
00402 \textcolor{comment}{/**}
00403 \textcolor{comment}{ * Stops all motors; significantly faster than looping through all motor ports and calling}
00404 \textcolor{comment}{ * motorSet(channel, 0) on each one.}
00405 \textcolor{comment}{ */}
00406 \textcolor{keywordtype}{void} motorStopAll();
00407 
00408 \textcolor{comment}{/**}
00409 \textcolor{comment}{ * Initializes VEX speaker support.}
00410 \textcolor{comment}{ *}
00411 \textcolor{comment}{ * The VEX speaker is not thread safe; it can only be used from one task at a time. Using the}
00412 \textcolor{comment}{ * VEX speaker may impact robot performance. Teams may benefit from an if statement that only}
00413 \textcolor{comment}{ * enables sound if isOnline() returns false.}
00414 \textcolor{comment}{ */}
00415 \textcolor{keywordtype}{void} speakerInit();
00416 \textcolor{comment}{/**}
00417 \textcolor{comment}{ * Plays up to three RTTTL (Ring Tone Text Transfer Language) songs simultaneously over the}
00418 \textcolor{comment}{ * VEX speaker. The audio is mixed to allow polyphonic sound to be played. Many simple songs}
00419 \textcolor{comment}{ * are available in RTTTL format online, or compose your own.}
00420 \textcolor{comment}{ *}
00421 \textcolor{comment}{ * The song must not be NULL, but unused tracks within the song can be set to NULL. If any of}
00422 \textcolor{comment}{ * the three song tracks is invalid, the result of this function is undefined.}
00423 \textcolor{comment}{ *}
00424 \textcolor{comment}{ * The VEX speaker is not thread safe; it can only be used from one task at a time. Using the}
00425 \textcolor{comment}{ * VEX speaker may impact robot performance. Teams may benefit from an if statement that only}
00426 \textcolor{comment}{ * enables sound if isOnline() returns false.}
00427 \textcolor{comment}{ *}
00428 \textcolor{comment}{ * @param songs an array of up to three (3) RTTTL songs as string values to play}
00429 \textcolor{comment}{ */}
00430 \textcolor{keywordtype}{void} speakerPlayArray(\textcolor{keyword}{const} \textcolor{keywordtype}{char} * * songs);
00431 \textcolor{comment}{/**}
00432 \textcolor{comment}{ * Plays an RTTTL (Ring Tone Text Transfer Language) song over the VEX speaker. Many simple}
00433 \textcolor{comment}{ * songs are available in RTTTL format online, or compose your own.}
00434 \textcolor{comment}{ *}
00435 \textcolor{comment}{ * The song must not be NULL. If an invalid song is specified, the result of this function is}
00436 \textcolor{comment}{ * undefined.}
00437 \textcolor{comment}{ *}
00438 \textcolor{comment}{ * The VEX speaker is not thread safe; it can only be used from one task at a time. Using the}
00439 \textcolor{comment}{ * VEX speaker may impact robot performance. Teams may benefit from an if statement that only}
00440 \textcolor{comment}{ * enables sound if isOnline() returns false.}
00441 \textcolor{comment}{ *}
00442 \textcolor{comment}{ * @param song the RTTTL song as a string value to play}
00443 \textcolor{comment}{ */}
00444 \textcolor{keywordtype}{void} speakerPlayRtttl(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *song);
00445 \textcolor{comment}{/**}
00446 \textcolor{comment}{ * Powers down and disables the VEX speaker.}
00447 \textcolor{comment}{ *}
00448 \textcolor{comment}{ * If a song is currently being played in another task, the behavior of this function is}
00449 \textcolor{comment}{ * undefined, since the VEX speaker is not thread safe.}
00450 \textcolor{comment}{ */}
00451 \textcolor{keywordtype}{void} speakerShutdown();
00452 
00453 \textcolor{comment}{// -------------------- VEX sensor control functions --------------------}
00454 
00455 \textcolor{comment}{/**}
00456 \textcolor{comment}{ * IME addresses end at 0x1F. Actually using more than 10 (address 0x1A) encoders will cause}
00457 \textcolor{comment}{ * unreliable communications.}
00458 \textcolor{comment}{ */}
00459 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{IME\_ADDR\_MAX} 0x1F
00460 
00461 \textcolor{comment}{/**}
00462 \textcolor{comment}{ * Initializes all IMEs.}
00463 \textcolor{comment}{ *}
00464 \textcolor{comment}{ * IMEs are assigned sequential incrementing addresses, beginning with the first IME on the}
00465 \textcolor{comment}{ * chain (closest to the VEX Cortex I2C port). Therefore, a given configuration of IMEs will}
00466 \textcolor{comment}{ * always have the same ID assigned to each encoder. The addresses range from 0 to}
00467 \textcolor{comment}{ * IME\_ADDR\_MAX, so the first encoder gets 0, the second gets 1, ...}
00468 \textcolor{comment}{ *}
00469 \textcolor{comment}{ * This function should most likely be used in initialize(). Do not use it in initializeIO() or}
00470 \textcolor{comment}{ * at any other time when the scheduler is paused (like an interrupt). Checking the return}
00471 \textcolor{comment}{ * value of this function is important to ensure that all IMEs are plugged in and responding as}
00472 \textcolor{comment}{ * expected.}
00473 \textcolor{comment}{ *}
00474 \textcolor{comment}{ * This function, unlike the other IME functions, is not thread safe. If using imeInitializeAll}
00475 \textcolor{comment}{ * to re-initialize encoders, calls to other IME functions might behave unpredictably during}
00476 \textcolor{comment}{ * this function's execution.}
00477 \textcolor{comment}{ *}
00478 \textcolor{comment}{ * @return the number of IMEs successfully initialized.}
00479 \textcolor{comment}{ */}
00480 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} imeInitializeAll();
00481 \textcolor{comment}{/**}
00482 \textcolor{comment}{ * Gets the current 32-bit count of the specified IME.}
00483 \textcolor{comment}{ *}
00484 \textcolor{comment}{ * Much like the count for a quadrature encoder, the tick count is signed and cumulative.}
00485 \textcolor{comment}{ * The value reflects total counts since the last reset. Different VEX Motor Encoders have a}
00486 \textcolor{comment}{ * different number of counts per revolution:}
00487 \textcolor{comment}{ *}
00488 \textcolor{comment}{ * * \(\backslash\)c 240.448 for the 269 IME}
00489 \textcolor{comment}{ * * \(\backslash\)c 627.2 for the 393 IME in high torque mode (factory default)}
00490 \textcolor{comment}{ * * \(\backslash\)c 392 for the 393 IME in high speed mode}
00491 \textcolor{comment}{ *}
00492 \textcolor{comment}{ * If the IME address is invalid, or the IME has not been reset or initialized, the value}
00493 \textcolor{comment}{ * stored in *value is undefined.}
00494 \textcolor{comment}{ *}
00495 \textcolor{comment}{ * @param address the IME address to fetch from 0 to IME\_ADDR\_MAX}
00496 \textcolor{comment}{ * @param value a pointer to the location where the value will be stored (obtained using the}
00497 \textcolor{comment}{ * "&" operator on the target variable name e.g. <code>imeGet(2, &counts)</code>)}
00498 \textcolor{comment}{ * @return true if the count was successfully read and the value stored in *value is valid;}
00499 \textcolor{comment}{ * false otherwise}
00500 \textcolor{comment}{ */}
00501 \textcolor{keywordtype}{bool} imeGet(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} address, \textcolor{keywordtype}{int} *value);
00502 \textcolor{comment}{/**}
00503 \textcolor{comment}{ * Gets the current rotational velocity of the specified IME.}
00504 \textcolor{comment}{ *}
00505 \textcolor{comment}{ * In this version of PROS, the velocity is positive if the IME count is increasing and}
00506 \textcolor{comment}{ * negative if the IME count is decreasing. The velocity is in RPM of the internal encoder}
00507 \textcolor{comment}{ * wheel. Since checking the IME for its type cannot reveal whether the motor gearing is}
00508 \textcolor{comment}{ * high speed or high torque (in the 2-Wire Motor 393 case), the user must divide the return}
00509 \textcolor{comment}{ * value by the number of output revolutions per encoder revolution:}
00510 \textcolor{comment}{ *}
00511 \textcolor{comment}{ * * \(\backslash\)c 30.056 for the 269 IME}
00512 \textcolor{comment}{ * * \(\backslash\)c 39.2 for the 393 IME in high torque mode (factory default)}
00513 \textcolor{comment}{ * * \(\backslash\)c 24.5 for the 393 IME in high speed mode}
00514 \textcolor{comment}{ *}
00515 \textcolor{comment}{ * If the IME address is invalid, or the IME has not been reset or initialized, the value}
00516 \textcolor{comment}{ * stored in *value is undefined.}
00517 \textcolor{comment}{ *}
00518 \textcolor{comment}{ * @param address the IME address to fetch from 0 to IME\_ADDR\_MAX}
00519 \textcolor{comment}{ * @param value a pointer to the location where the value will be stored (obtained using the}
00520 \textcolor{comment}{ * "&" operator on the target variable name e.g. <code>imeGetVelocity(2, &counts)</code>)}
00521 \textcolor{comment}{ * @return true if the velocity was successfully read and the value stored in *value is valid;}
00522 \textcolor{comment}{ * false otherwise}
00523 \textcolor{comment}{ */}
00524 \textcolor{keywordtype}{bool} imeGetVelocity(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} address, \textcolor{keywordtype}{int} *value);
00525 \textcolor{comment}{/**}
00526 \textcolor{comment}{ * Resets the specified IME's counters to zero.}
00527 \textcolor{comment}{ *}
00528 \textcolor{comment}{ * This method can be used while the IME is rotating.}
00529 \textcolor{comment}{ *}
00530 \textcolor{comment}{ * @param address the IME address to reset from 0 to IME\_ADDR\_MAX}
00531 \textcolor{comment}{ * @return true if the reset succeeded; false otherwise}
00532 \textcolor{comment}{ */}
00533 \textcolor{keywordtype}{bool} imeReset(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} address);
00534 \textcolor{comment}{/**}
00535 \textcolor{comment}{ * Shuts down all IMEs on the chain; their addresses return to the default and the stored}
00536 \textcolor{comment}{ * counts and velocities are lost. This function, unlike the other IME functions, is not}
00537 \textcolor{comment}{ * thread safe.}
00538 \textcolor{comment}{ *}
00539 \textcolor{comment}{ * To use the IME chain again, wait at least 0.25 seconds before using imeInitializeAll again.}
00540 \textcolor{comment}{ */}
00541 \textcolor{keywordtype}{void} imeShutdown();
00542 
00543 \textcolor{comment}{/**}
00544 \textcolor{comment}{ * Reference type for an initialized gyro.}
00545 \textcolor{comment}{ *}
00546 \textcolor{comment}{ * Gyro information is stored as an opaque pointer to a structure in memory; as this is a}
00547 \textcolor{comment}{ * pointer type, it can be safely passed or stored by value.}
00548 \textcolor{comment}{ */}
00549 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} * Gyro;
00550 
00551 \textcolor{comment}{/**}
00552 \textcolor{comment}{ * Gets the current gyro angle in degrees, rounded to the nearest degree.}
00553 \textcolor{comment}{ *}
00554 \textcolor{comment}{ * There are 360 degrees in a circle.}
00555 \textcolor{comment}{ *}
00556 \textcolor{comment}{ * @param gyro the Gyro object from gyroInit() to read}
00557 \textcolor{comment}{ * @return the signed and cumulative number of degrees rotated around the gyro's vertical axis}
00558 \textcolor{comment}{ * since the last start or reset}
00559 \textcolor{comment}{ */}
00560 \textcolor{keywordtype}{int} gyroGet(Gyro gyro);
00561 \textcolor{comment}{/**}
00562 \textcolor{comment}{ * Initializes and enables a gyro on an analog port.}
00563 \textcolor{comment}{ *}
00564 \textcolor{comment}{ * NULL will be returned if the port is invalid or the gyro is already in use. Initializing a}
00565 \textcolor{comment}{ * gyro implicitly calibrates it and resets its count. Do not move the robot while the gyro is}
00566 \textcolor{comment}{ * being calibrated. It is suggested to call this function in initialize() and to place the}
00567 \textcolor{comment}{ * robot in its final position before powering it on.}
00568 \textcolor{comment}{ *}
00569 \textcolor{comment}{ * The multiplier parameter can tune the gyro to adapt to specific sensors. The default value}
00570 \textcolor{comment}{ * at this time is 196; higher values will increase the number of degrees reported for a fixed}
00571 \textcolor{comment}{ * actual rotation, while lower values will decrease the number of degrees reported. If your}
00572 \textcolor{comment}{ * robot is consistently turning too far, increase the multiplier, and if it is not turning}
00573 \textcolor{comment}{ * far enough, decrease the multiplier.}
00574 \textcolor{comment}{ *}
00575 \textcolor{comment}{ * @param port the analog port to use from 1-8}
00576 \textcolor{comment}{ * @param multiplier an optional constant to tune the gyro readings; use 0 for the default}
00577 \textcolor{comment}{ * value}
00578 \textcolor{comment}{ * @return a Gyro object to be stored and used for later calls to gyro functions}
00579 \textcolor{comment}{ */}
00580 Gyro gyroInit(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} port, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} multiplier);
00581 \textcolor{comment}{/**}
00582 \textcolor{comment}{ * Resets the gyro to zero.}
00583 \textcolor{comment}{ *}
00584 \textcolor{comment}{ * It is safe to use this method while a gyro is enabled. It is not necessary to call this}
00585 \textcolor{comment}{ * method before stopping or starting a gyro.}
00586 \textcolor{comment}{ *}
00587 \textcolor{comment}{ * @param gyro the Gyro object from gyroInit() to reset}
00588 \textcolor{comment}{ */}
00589 \textcolor{keywordtype}{void} gyroReset(Gyro gyro);
00590 \textcolor{comment}{/**}
00591 \textcolor{comment}{ * Stops and disables the gyro.}
00592 \textcolor{comment}{ *}
00593 \textcolor{comment}{ * Gyros use processing power, so disabling unused gyros increases code performance.}
00594 \textcolor{comment}{ * The gyro's position will be retained.}
00595 \textcolor{comment}{ *}
00596 \textcolor{comment}{ * @param gyro the Gyro object from gyroInit() to stop}
00597 \textcolor{comment}{ */}
00598 \textcolor{keywordtype}{void} gyroShutdown(Gyro gyro);
00599 
00600 \textcolor{comment}{/**}
00601 \textcolor{comment}{ * Reference type for an initialized encoder.}
00602 \textcolor{comment}{ *}
00603 \textcolor{comment}{ * Encoder information is stored as an opaque pointer to a structure in memory; as this is a}
00604 \textcolor{comment}{ * pointer type, it can be safely passed or stored by value.}
00605 \textcolor{comment}{ */}
00606 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} * Encoder;
00607 \textcolor{comment}{/**}
00608 \textcolor{comment}{ * Gets the number of ticks recorded by the encoder.}
00609 \textcolor{comment}{ *}
00610 \textcolor{comment}{ * There are 360 ticks in one revolution.}
00611 \textcolor{comment}{ *}
00612 \textcolor{comment}{ * @param enc the Encoder object from encoderInit() to read}
00613 \textcolor{comment}{ * @return the signed and cumulative number of counts since the last start or reset}
00614 \textcolor{comment}{ */}
00615 \textcolor{keywordtype}{int} encoderGet(Encoder enc);
00616 \textcolor{comment}{/**}
00617 \textcolor{comment}{ * Initializes and enables a quadrature encoder on two digital ports.}
00618 \textcolor{comment}{ *}
00619 \textcolor{comment}{ * Neither the top port nor the bottom port can be digital port 10. NULL will be returned if}
00620 \textcolor{comment}{ * either port is invalid or the encoder is already in use. Initializing an encoder implicitly}
00621 \textcolor{comment}{ * resets its count.}
00622 \textcolor{comment}{ *}
00623 \textcolor{comment}{ * @param portTop the "top" wire from the encoder sensor with the removable cover side UP}
00624 \textcolor{comment}{ * @param portBottom the "bottom" wire from the encoder sensor}
00625 \textcolor{comment}{ * @param reverse if "true", the sensor will count in the opposite direction}
00626 \textcolor{comment}{ * @return an Encoder object to be stored and used for later calls to encoder functions}
00627 \textcolor{comment}{ */}
00628 Encoder encoderInit(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} portTop, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} portBottom, \textcolor{keywordtype}{bool} reverse);
00629 \textcolor{comment}{/**}
00630 \textcolor{comment}{ * Resets the encoder to zero.}
00631 \textcolor{comment}{ *}
00632 \textcolor{comment}{ * It is safe to use this method while an encoder is enabled. It is not necessary to call this}
00633 \textcolor{comment}{ * method before stopping or starting an encoder.}
00634 \textcolor{comment}{ *}
00635 \textcolor{comment}{ * @param enc the Encoder object from encoderInit() to reset}
00636 \textcolor{comment}{ */}
00637 \textcolor{keywordtype}{void} encoderReset(Encoder enc);
00638 \textcolor{comment}{/**}
00639 \textcolor{comment}{ * Stops and disables the encoder.}
00640 \textcolor{comment}{ *}
00641 \textcolor{comment}{ * Encoders use processing power, so disabling unused encoders increases code performance.}
00642 \textcolor{comment}{ * The encoder's count will be retained.}
00643 \textcolor{comment}{ *}
00644 \textcolor{comment}{ * @param enc the Encoder object from encoderInit() to stop}
00645 \textcolor{comment}{ */}
00646 \textcolor{keywordtype}{void} encoderShutdown(Encoder enc);
00647 
00648 \textcolor{comment}{/**}
00649 \textcolor{comment}{ * This value is returned if the sensor cannot find a reasonable value to return.}
00650 \textcolor{comment}{ */}
00651 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ULTRA\_BAD\_RESPONSE} \textcolor{preprocessor}{-}1
00652 
00653 \textcolor{comment}{/**}
00654 \textcolor{comment}{ * Reference type for an initialized ultrasonic sensor.}
00655 \textcolor{comment}{ *}
00656 \textcolor{comment}{ * Ultrasonic information is stored as an opaque pointer to a structure in memory; as this is a}
00657 \textcolor{comment}{ * pointer type, it can be safely passed or stored by value.}
00658 \textcolor{comment}{ */}
00659 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} * Ultrasonic;
00660 \textcolor{comment}{/**}
00661 \textcolor{comment}{ * Gets the current ultrasonic sensor value in centimeters.}
00662 \textcolor{comment}{ *}
00663 \textcolor{comment}{ * If no object was found or if the ultrasonic sensor is polled while it is pinging and waiting}
00664 \textcolor{comment}{ * for a response, -1 (ULTRA\_BAD\_RESPONSE) is returned.}
00665 \textcolor{comment}{ * If the ultrasonic sensor was never started, the return value is undefined. Round and fluffy}
00666 \textcolor{comment}{ * objects can cause inaccurate values to be returned.}
00667 \textcolor{comment}{ *}
00668 \textcolor{comment}{ * @param ult the Ultrasonic object from ultrasonicInit() to read}
00669 \textcolor{comment}{ * @return the distance to the nearest object in centimeters}
00670 \textcolor{comment}{ */}
00671 \textcolor{keywordtype}{int} ultrasonicGet(Ultrasonic ult);
00672 \textcolor{comment}{/**}
00673 \textcolor{comment}{ * Initializes an ultrasonic sensor on the specified digital ports.}
00674 \textcolor{comment}{ *}
00675 \textcolor{comment}{ * The ultrasonic sensor will be polled in the background in concert with the other sensors}
00676 \textcolor{comment}{ * registered using this method. NULL will be returned if either port is invalid or the}
00677 \textcolor{comment}{ * ultrasonic sensor port is already in use.}
00678 \textcolor{comment}{ *}
00679 \textcolor{comment}{ * @param portEcho the port connected to the orange cable from 1-9,11-12}
00680 \textcolor{comment}{ * @param portPing the port connected to the yellow cable from 1-12}
00681 \textcolor{comment}{ * @return an Ultrasonic object to be stored and used for later calls to ultrasonic functions}
00682 \textcolor{comment}{ */}
00683 Ultrasonic ultrasonicInit(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} portEcho, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} portPing);
00684 \textcolor{comment}{/**}
00685 \textcolor{comment}{ * Stops and disables the ultrasonic sensor.}
00686 \textcolor{comment}{ *}
00687 \textcolor{comment}{ * The last distance it had before stopping will be retained. One more ping operation may occur}
00688 \textcolor{comment}{ * before the sensor is fully disabled.}
00689 \textcolor{comment}{ *}
00690 \textcolor{comment}{ * @param ult the Ultrasonic object from ultrasonicInit() to stop}
00691 \textcolor{comment}{ */}
00692 \textcolor{keywordtype}{void} ultrasonicShutdown(Ultrasonic ult);
00693 
00694 \textcolor{comment}{// -------------------- Custom sensor control functions --------------------}
00695 
00696 \textcolor{comment}{// ---- I2C port control ----}
00697 \textcolor{comment}{/**}
00698 \textcolor{comment}{ * i2cRead - Reads the specified number of data bytes from the specified 7-bit I2C address. The}
00699 \textcolor{comment}{ * bytes will be stored at the specified location. Returns true if successful or false if}
00700 \textcolor{comment}{ * failed. If only some bytes could be read, false is still returned.}
00701 \textcolor{comment}{ *}
00702 \textcolor{comment}{ * The I2C address should be right-aligned; the R/W bit is automatically supplied.}
00703 \textcolor{comment}{ *}
00704 \textcolor{comment}{ * Since most I2C devices use an 8-bit register architecture, this method has limited}
00705 \textcolor{comment}{ * usefulness. Consider i2cReadRegister instead for the vast majority of applications.}
00706 \textcolor{comment}{ */}
00707 \textcolor{keywordtype}{bool} i2cRead(uint8\_t addr, uint8\_t *data, uint16\_t count);
00708 \textcolor{comment}{/**}
00709 \textcolor{comment}{ * i2cReadRegister - Reads the specified amount of data from the given register address on}
00710 \textcolor{comment}{ * the specified 7-bit I2C address. Returns true if successful or false if failed. If only some}
00711 \textcolor{comment}{ * bytes could be read, false is still returned.}
00712 \textcolor{comment}{ *}
00713 \textcolor{comment}{ * The I2C address should be right-aligned; the R/W bit is automatically supplied.}
00714 \textcolor{comment}{ *}
00715 \textcolor{comment}{ * Most I2C devices support an auto-increment address feature, so using this method to read}
00716 \textcolor{comment}{ * more than one byte will usually read a block of sequential registers. Try to merge reads to}
00717 \textcolor{comment}{ * separate registers into a larger read using this function whenever possible to improve code}
00718 \textcolor{comment}{ * reliability, even if a few intermediate values need to be thrown away.}
00719 \textcolor{comment}{ */}
00720 \textcolor{keywordtype}{bool} i2cReadRegister(uint8\_t addr, uint8\_t reg, uint8\_t *value, uint16\_t count);
00721 \textcolor{comment}{/**}
00722 \textcolor{comment}{ * i2cWrite - Writes the specified number of data bytes to the specified 7-bit I2C address.}
00723 \textcolor{comment}{ * Returns true if successful or false if failed. If only smoe bytes could be written, false}
00724 \textcolor{comment}{ * is still returned.}
00725 \textcolor{comment}{ *}
00726 \textcolor{comment}{ * The I2C address should be right-aligned; the R/W bit is automatically supplied.}
00727 \textcolor{comment}{ *}
00728 \textcolor{comment}{ * Since most I2C devices use an 8-bit register architecture, this method is mostly useful for}
00729 \textcolor{comment}{ * setting the register position (most devices remember the last-used address) or writing a}
00730 \textcolor{comment}{ * sequence of bytes to one register address using an auto-increment feature. In these cases,}
00731 \textcolor{comment}{ * the first byte written from the data buffer should have the register address to use.}
00732 \textcolor{comment}{ */}
00733 \textcolor{keywordtype}{bool} i2cWrite(uint8\_t addr, uint8\_t *data, uint16\_t count);
00734 \textcolor{comment}{/**}
00735 \textcolor{comment}{ * i2cWriteRegister - Writes the specified data byte to a register address on the specified}
00736 \textcolor{comment}{ * 7-bit I2C address. Returns true if successful or false if failed.}
00737 \textcolor{comment}{ *}
00738 \textcolor{comment}{ * The I2C address should be right-aligned; the R/W bit is automatically supplied.}
00739 \textcolor{comment}{ *}
00740 \textcolor{comment}{ * Only one byte can be written to each register address using this method. While useful for}
00741 \textcolor{comment}{ * the vast majority of I2C operations, writing multiple bytes requires the i2cWrite method.}
00742 \textcolor{comment}{ */}
00743 \textcolor{keywordtype}{bool} i2cWriteRegister(uint8\_t addr, uint8\_t reg, uint16\_t value);
00744 
00745 \textcolor{comment}{/**}
00746 \textcolor{comment}{ * PROS\_FILE is an integer referring to a stream for the standard I/O functions.}
00747 \textcolor{comment}{ *}
00748 \textcolor{comment}{ * PROS\_FILE * is the standard library method of referring to a file pointer, even though there is}
00749 \textcolor{comment}{ * actually nothing there.}
00750 \textcolor{comment}{ */}
00751 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} PROS_FILE;
00752 
00753 
00754 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{FILE}
00755 \textcolor{comment}{/**}
00756 \textcolor{comment}{ * For convenience, FILE is defined as PROS\_FILE if it wasn't already defined. This provides}
00757 \textcolor{comment}{ * backwards compatability with PROS, but also allows libraries such as newlib to be incorporated}
00758 \textcolor{comment}{ * into PROS projects. If you're not using C++/newlib, you can disregard this and just use FILE.}
00759 \textcolor{comment}{ */}
00760 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{FILE} \textcolor{preprocessor}{PROS\_FILE}
00761 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00762 
00763 \textcolor{comment}{/**}
00764 \textcolor{comment}{ * Bit mask for usartInit() for 8 data bits (typical)}
00765 \textcolor{comment}{ */}
00766 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SERIAL\_DATABITS\_8} 0x0000
00767 \textcolor{comment}{/**}
00768 \textcolor{comment}{ * Bit mask for usartInit() for 9 data bits}
00769 \textcolor{comment}{ */}
00770 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SERIAL\_DATABITS\_9} 0x1000
00771 \textcolor{comment}{/**}
00772 \textcolor{comment}{ * Bit mask for usartInit() for 1 stop bit (typical)}
00773 \textcolor{comment}{ */}
00774 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SERIAL\_STOPBITS\_1} 0x0000
00775 \textcolor{comment}{/**}
00776 \textcolor{comment}{ * Bit mask for usartInit() for 2 stop bits}
00777 \textcolor{comment}{ */}
00778 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SERIAL\_STOPBITS\_2} 0x2000
00779 \textcolor{comment}{/**}
00780 \textcolor{comment}{ * Bit mask for usartInit() for No parity (typical)}
00781 \textcolor{comment}{ */}
00782 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SERIAL\_PARITY\_NONE} 0x0000
00783 \textcolor{comment}{/**}
00784 \textcolor{comment}{ * Bit mask for usartInit() for Even parity}
00785 \textcolor{comment}{ */}
00786 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SERIAL\_PARITY\_EVEN} 0x0400
00787 \textcolor{comment}{/**}
00788 \textcolor{comment}{ * Bit mask for usartInit() for Odd parity}
00789 \textcolor{comment}{ */}
00790 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SERIAL\_PARITY\_ODD} 0x0600
00791 \textcolor{comment}{/**}
00792 \textcolor{comment}{ * Specifies the default serial settings when used in usartInit()}
00793 \textcolor{comment}{ */}
00794 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SERIAL\_8N1} 0x0000
00795 
00796 \textcolor{comment}{/**}
00797 \textcolor{comment}{ * Initialize the specified serial interface with the given connection parameters.}
00798 \textcolor{comment}{ *}
00799 \textcolor{comment}{ * I/O to the port is accomplished using the "standard" I/O functions such as fputs(),}
00800 \textcolor{comment}{ * fprintf(), and fputc().}
00801 \textcolor{comment}{ *}
00802 \textcolor{comment}{ * Re-initializing an open port may cause loss of data in the buffers. This routine may be}
00803 \textcolor{comment}{ * safely called from initializeIO() or when the scheduler is paused. If I/O is attempted on a}
00804 \textcolor{comment}{ * serial port which has never been opened, the behavior will be the same as if the port had}
00805 \textcolor{comment}{ * been disabled.}
00806 \textcolor{comment}{ *}
00807 \textcolor{comment}{ * @param usart the port to open, either "uart1" or "uart2"}
00808 \textcolor{comment}{ * @param baud the baud rate to use from 2400 to 1000000 baud}
00809 \textcolor{comment}{ * @param flags a bit mask combination of the SERIAL\_* flags specifying parity, stop, and data}
00810 \textcolor{comment}{ * bits}
00811 \textcolor{comment}{ */}
00812 \textcolor{keywordtype}{void} usartInit(PROS_FILE *usart, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} baud, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} flags);
00813 \textcolor{comment}{/**}
00814 \textcolor{comment}{ * Disables the specified USART interface.}
00815 \textcolor{comment}{ *}
00816 \textcolor{comment}{ * Any data in the transmit and receive buffers will be lost. Attempts to read from the port}
00817 \textcolor{comment}{ * when it is disabled will deadlock, and attempts to write to it may deadlock depending on}
00818 \textcolor{comment}{ * the state of the buffer.}
00819 \textcolor{comment}{ *}
00820 \textcolor{comment}{ * @param usart the port to close, either "uart1" or "uart2"}
00821 \textcolor{comment}{ */}
00822 \textcolor{keywordtype}{void} usartShutdown(PROS_FILE *usart);
00823 
00824 \textcolor{comment}{// -------------------- Character input and output --------------------}
00825 
00826 \textcolor{comment}{/**}
00827 \textcolor{comment}{ * The standard output stream uses the PC debug terminal.}
00828 \textcolor{comment}{ */}
00829 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{stdout} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{PROS\_FILE} \textcolor{preprocessor}{*}\textcolor{preprocessor}{)}3\textcolor{preprocessor}{)}
00830 \textcolor{comment}{/**}
00831 \textcolor{comment}{ * The standard input stream uses the PC debug terminal.}
00832 \textcolor{comment}{ */}
00833 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{stdin} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{PROS\_FILE} \textcolor{preprocessor}{*}\textcolor{preprocessor}{)}3\textcolor{preprocessor}{)}
00834 \textcolor{comment}{/**}
00835 \textcolor{comment}{ * UART 1 on the Cortex; must be opened first using usartInit().}
00836 \textcolor{comment}{ */}
00837 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{uart1} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{PROS\_FILE} \textcolor{preprocessor}{*}\textcolor{preprocessor}{)}1\textcolor{preprocessor}{)}
00838 \textcolor{comment}{/**}
00839 \textcolor{comment}{ * UART 2 on the Cortex; must be opened first using usartInit().}
00840 \textcolor{comment}{ */}
00841 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{uart2} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{PROS\_FILE} \textcolor{preprocessor}{*}\textcolor{preprocessor}{)}2\textcolor{preprocessor}{)}
00842 
00843 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{EOF}
00844 \textcolor{comment}{/**}
00845 \textcolor{comment}{ * EOF is a value evaluating to -1.}
00846 \textcolor{comment}{ */}
00847 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{EOF} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{keywordtype}{int}\textcolor{preprocessor}{)}\textcolor{preprocessor}{-}1\textcolor{preprocessor}{)}
00848 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00849 
00850 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{SEEK\_SET}
00851 \textcolor{comment}{/**}
00852 \textcolor{comment}{ * SEEK\_SET is used in fseek() to denote an absolute position in bytes from the start of the}
00853 \textcolor{comment}{ * file.}
00854 \textcolor{comment}{ */}
00855 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define}       \textcolor{preprocessor}{SEEK\_SET} 0
00856 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00857 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{SEEK\_CUR}
00858 \textcolor{comment}{/**}
00859 \textcolor{comment}{ * SEEK\_CUR is used in fseek() to denote an relative position in bytes from the current file}
00860 \textcolor{comment}{ * location.}
00861 \textcolor{comment}{ */}
00862 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define}       \textcolor{preprocessor}{SEEK\_CUR} 1
00863 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00864 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{SEEK\_END}
00865 \textcolor{comment}{/**}
00866 \textcolor{comment}{ * SEEK\_END is used in fseek() to denote an absolute position in bytes from the end of the}
00867 \textcolor{comment}{ * file. The offset will most likely be negative in this case.}
00868 \textcolor{comment}{ */}
00869 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define}       \textcolor{preprocessor}{SEEK\_END} 2
00870 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00871 
00872 \textcolor{comment}{/**}
00873 \textcolor{comment}{ * Closes the specified file descriptor. This function does not work on communication ports;}
00874 \textcolor{comment}{ * use usartShutdown() instead.}
00875 \textcolor{comment}{ *}
00876 \textcolor{comment}{ * @param stream the file descriptor to close from fopen()}
00877 \textcolor{comment}{ */}
00878 \textcolor{keywordtype}{void} fclose(PROS_FILE *stream);
00879 \textcolor{comment}{/**}
00880 \textcolor{comment}{ * Returns the number of characters that can be read without blocking (the number of}
00881 \textcolor{comment}{ * characters available) from the specified stream. This only works for communication ports and}
00882 \textcolor{comment}{ * files in Read mode; for files in Write mode, 0 is always returned.}
00883 \textcolor{comment}{ *}
00884 \textcolor{comment}{ * This function may underestimate, but will not overestimate, the number of characters which}
00885 \textcolor{comment}{ * meet this criterion.}
00886 \textcolor{comment}{ *}
00887 \textcolor{comment}{ * @param stream the stream to read (stdin, uart1, uart2, or an open file in Read mode)}
00888 \textcolor{comment}{ * @return the number of characters which meet this criterion; if this number cannot be}
00889 \textcolor{comment}{ * determined, returns 0}
00890 \textcolor{comment}{ */}
00891 \textcolor{keywordtype}{int} fcount(PROS_FILE *stream);
00892 \textcolor{comment}{/**}
00893 \textcolor{comment}{ * Delete the specified file if it exists and is not currently open.}
00894 \textcolor{comment}{ *}
00895 \textcolor{comment}{ * The file will actually be erased from memory on the next re-boot. A physical power cycle is}
00896 \textcolor{comment}{ * required to purge deleted files and free their allocated space for new files to be written.}
00897 \textcolor{comment}{ * Deleted files are still considered inaccessible to fopen() in Read mode.}
00898 \textcolor{comment}{ *}
00899 \textcolor{comment}{ * @param file the file name to erase}
00900 \textcolor{comment}{ * @return 0 if the file was deleted, or 1 if the file could not be found}
00901 \textcolor{comment}{ */}
00902 \textcolor{keywordtype}{int} fdelete(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file);
00903 \textcolor{comment}{/**}
00904 \textcolor{comment}{ * Checks to see if the specified stream is at its end. This only works for communication ports}
00905 \textcolor{comment}{ * and files in Read mode; for files in Write mode, 1 is always returned.}
00906 \textcolor{comment}{ *}
00907 \textcolor{comment}{ * @param stream the channel to check (stdin, uart1, uart2, or an open file in Read mode)}
00908 \textcolor{comment}{ * @return 0 if the stream is not at EOF, or 1 otherwise.}
00909 \textcolor{comment}{ */}
00910 \textcolor{keywordtype}{int} feof(PROS_FILE *stream);
00911 \textcolor{comment}{/**}
00912 \textcolor{comment}{ * Flushes the data on the specified file channel open in Write mode. This function has no}
00913 \textcolor{comment}{ * effect on a communication port or a file in Read mode, as these streams are always flushed as}
00914 \textcolor{comment}{ * quickly as possible by the kernel.}
00915 \textcolor{comment}{ *}
00916 \textcolor{comment}{ * Successful completion of an fflush function on a file in Write mode cannot guarantee that}
00917 \textcolor{comment}{ * the file is vaild until fclose() is used on that file descriptor.}
00918 \textcolor{comment}{ *}
00919 \textcolor{comment}{ * @param stream the channel to flush (an open file in Write mode)}
00920 \textcolor{comment}{ * @return 0 if the data was successfully flushed, EOF otherwise}
00921 \textcolor{comment}{ */}
00922 \textcolor{keywordtype}{int} fflush(PROS_FILE *stream);
00923 \textcolor{comment}{/**}
00924 \textcolor{comment}{ * Reads and returns one character from the specified stream, blocking until complete.}
00925 \textcolor{comment}{ *}
00926 \textcolor{comment}{ * Do not use fgetc() on a VEX LCD port; deadlock may occur.}
00927 \textcolor{comment}{ *}
00928 \textcolor{comment}{ * @param stream the stream to read (stdin, uart1, uart2, or an open file in Read mode)}
00929 \textcolor{comment}{ * @return the next character from 0 to 255, or -1 if no character can be read}
00930 \textcolor{comment}{ */}
00931 \textcolor{keywordtype}{int} fgetc(PROS_FILE *stream);
00932 \textcolor{comment}{/**}
00933 \textcolor{comment}{ * Reads a string from the specified stream, storing the characters into the memory at str.}
00934 \textcolor{comment}{ * Characters will be read until the specified limit is reached, a new line is found, or the}
00935 \textcolor{comment}{ * end of file is reached.}
00936 \textcolor{comment}{ *}
00937 \textcolor{comment}{ * If the stream is already at end of file (for files in Read mode), NULL will be returned;}
00938 \textcolor{comment}{ * otherwise, at least one character will be read and stored into str.}
00939 \textcolor{comment}{ *}
00940 \textcolor{comment}{ * @param str the location where the characters read will be stored}
00941 \textcolor{comment}{ * @param num the maximum number of characters to store; at most (num - 1) characters will be}
00942 \textcolor{comment}{ * read, with a null terminator ('\(\backslash\)0') automatically appended}
00943 \textcolor{comment}{ * @param stream the channel to read (stdin, uart1, uart2, or an open file in Read mode)}
00944 \textcolor{comment}{ * @return str, or NULL if zero characters could be read}
00945 \textcolor{comment}{ */}
00946 \textcolor{keywordtype}{char}* fgets(\textcolor{keywordtype}{char} *str, \textcolor{keywordtype}{int} num, PROS_FILE *stream);
00947 \textcolor{comment}{/**}
00948 \textcolor{comment}{ * Opens the given file in the specified mode. The file name is truncated to eight characters.}
00949 \textcolor{comment}{ * Only four files can be in use simultaneously in any given time, with at most one of those}
00950 \textcolor{comment}{ * files in Write mode. This function does not work on communication ports; use usartInit()}
00951 \textcolor{comment}{ * instead.}
00952 \textcolor{comment}{ *}
00953 \textcolor{comment}{ * mode can be "r" or "w". Due to the nature of the VEX Cortex memory, the "r+", "w+", and "a"}
00954 \textcolor{comment}{ * modes are not supported by the file system.}
00955 \textcolor{comment}{ *}
00956 \textcolor{comment}{ * Opening a file that does not exist in Read mode will fail and return NULL, but opening a new}
00957 \textcolor{comment}{ * file in Write mode will create it if there is space. Opening a file that already exists in}
00958 \textcolor{comment}{ * Write mode will destroy the contents and create a new blank file if space is available.}
00959 \textcolor{comment}{ *}
00960 \textcolor{comment}{ * There are important considerations when using of the file system on the VEX Cortex. Reading}
00961 \textcolor{comment}{ * from files is safe, but writing to files should only be performed when robot actuators have}
00962 \textcolor{comment}{ * been stopped. PROS will attempt to continue to handle events during file writes, but most}
00963 \textcolor{comment}{ * user tasks cannot execute during file writing. Powering down the VEX Cortex mid-write may}
00964 \textcolor{comment}{ * cause file system corruption.}
00965 \textcolor{comment}{ *}
00966 \textcolor{comment}{ * @param file the file name}
00967 \textcolor{comment}{ * @param mode the file mode}
00968 \textcolor{comment}{ * @return a file descriptor pointing to the new file, or NULL if the file could not be opened}
00969 \textcolor{comment}{ */}
00970 PROS_FILE * fopen(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode);
00971 \textcolor{comment}{/**}
00972 \textcolor{comment}{ * Prints the simple string to the specified stream.}
00973 \textcolor{comment}{ *}
00974 \textcolor{comment}{ * This method is much, much faster than fprintf() and does not add a new line like fputs().}
00975 \textcolor{comment}{ * Do not use fprint() on a VEX LCD port. Use lcdSetText() instead.}
00976 \textcolor{comment}{ *}
00977 \textcolor{comment}{ * @param string the string to write}
00978 \textcolor{comment}{ * @param stream the stream to write (stdout, uart1, uart2, or an open file in Write mode)}
00979 \textcolor{comment}{ */}
00980 \textcolor{keywordtype}{void} fprint(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *string, PROS_FILE *stream);
00981 \textcolor{comment}{/**}
00982 \textcolor{comment}{ * Writes one character to the specified stream.}
00983 \textcolor{comment}{ *}
00984 \textcolor{comment}{ * Do not use fputc() on a VEX LCD port. Use lcdSetText() instead.}
00985 \textcolor{comment}{ *}
00986 \textcolor{comment}{ * @param value the character to write (a value of type "char" can be used)}
00987 \textcolor{comment}{ * @param stream the stream to write (stdout, uart1, uart2, or an open file in Write mode)}
00988 \textcolor{comment}{ * @return the character written}
00989 \textcolor{comment}{ */}
00990 \textcolor{keywordtype}{int} fputc(\textcolor{keywordtype}{int} value, PROS_FILE *stream);
00991 \textcolor{comment}{/**}
00992 \textcolor{comment}{ * Behaves the same as the "fprint" function, and appends a trailing newline ("\(\backslash\)n").}
00993 \textcolor{comment}{ *}
00994 \textcolor{comment}{ * Do not use fputs() on a VEX LCD port. Use lcdSetText() instead.}
00995 \textcolor{comment}{ *}
00996 \textcolor{comment}{ * @param string the string to write}
00997 \textcolor{comment}{ * @param stream the stream to write (stdout, uart1, uart2, or an open file in Write mode)}
00998 \textcolor{comment}{ * @return the number of characters written, excluding the new line}
00999 \textcolor{comment}{ */}
01000 \textcolor{keywordtype}{int} fputs(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *string, PROS_FILE *stream);
01001 \textcolor{comment}{/**}
01002 \textcolor{comment}{ * Reads data from a stream into memory. Returns the number of bytes thus read.}
01003 \textcolor{comment}{ *}
01004 \textcolor{comment}{ * If the memory at ptr cannot store (size * count) bytes, undefined behavior occurs.}
01005 \textcolor{comment}{ *}
01006 \textcolor{comment}{ * @param ptr a pointer to where the data will be stored}
01007 \textcolor{comment}{ * @param size the size of each data element to read in bytes}
01008 \textcolor{comment}{ * @param count the number of data elements to read}
01009 \textcolor{comment}{ * @param stream the stream to read (stdout, uart1, uart2, or an open file in Read mode)}
01010 \textcolor{comment}{ * @return the number of bytes successfully read}
01011 \textcolor{comment}{ */}
01012 size\_t fread(\textcolor{keywordtype}{void} *ptr, size\_t size, size\_t count, PROS_FILE *stream);
01013 \textcolor{comment}{/**}
01014 \textcolor{comment}{ * Seeks within a file open in Read mode. This function will fail when used on a file in Write}
01015 \textcolor{comment}{ * mode or on any communications port.}
01016 \textcolor{comment}{ *}
01017 \textcolor{comment}{ * @param stream the stream to seek within}
01018 \textcolor{comment}{ * @param offset the location within the stream to seek}
01019 \textcolor{comment}{ * @param origin the reference location for offset: SEEK\_CUR, SEEK\_SET, or SEEK\_END}
01020 \textcolor{comment}{ * @return 0 if the seek was successful, or 1 otherwise}
01021 \textcolor{comment}{ */}
01022 \textcolor{keywordtype}{int} fseek(PROS_FILE *stream, \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} offset, \textcolor{keywordtype}{int} origin);
01023 \textcolor{comment}{/**}
01024 \textcolor{comment}{ * Returns the current position of the stream. This function works on files in either Read or}
01025 \textcolor{comment}{ * Write mode, but will fail on communications ports.}
01026 \textcolor{comment}{ *}
01027 \textcolor{comment}{ * @param stream the stream to check}
01028 \textcolor{comment}{ * @return the offset of the stream, or -1 if the offset could not be determined}
01029 \textcolor{comment}{ */}
01030 \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} ftell(PROS_FILE *stream);
01031 \textcolor{comment}{/**}
01032 \textcolor{comment}{ * Writes data from memory to a stream. Returns the number of bytes thus written.}
01033 \textcolor{comment}{ *}
01034 \textcolor{comment}{ * If the memory at ptr is not as long as (size * count) bytes, undefined behavior occurs.}
01035 \textcolor{comment}{ *}
01036 \textcolor{comment}{ * @param ptr a pointer to the data to write}
01037 \textcolor{comment}{ * @param size the size of each data element to write in bytes}
01038 \textcolor{comment}{ * @param count the number of data elements to write}
01039 \textcolor{comment}{ * @param stream the stream to write (stdout, uart1, uart2, or an open file in Write mode)}
01040 \textcolor{comment}{ * @return the number of bytes successfully written}
01041 \textcolor{comment}{ */}
01042 size\_t fwrite(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *ptr, size\_t size, size\_t count, PROS_FILE *stream);
01043 \textcolor{comment}{/**}
01044 \textcolor{comment}{ * Reads and returns one character from "stdin", which is the PC debug terminal.}
01045 \textcolor{comment}{ *}
01046 \textcolor{comment}{ * @return the next character from 0 to 255, or -1 if no character can be read}
01047 \textcolor{comment}{ */}
01048 \textcolor{keywordtype}{int} getchar();
01049 \textcolor{comment}{/**}
01050 \textcolor{comment}{ * Prints the simple string to the debug terminal without formatting.}
01051 \textcolor{comment}{ *}
01052 \textcolor{comment}{ * This method is much, much faster than printf().}
01053 \textcolor{comment}{ *}
01054 \textcolor{comment}{ * @param string the string to write}
01055 \textcolor{comment}{ */}
01056 \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *string);
01057 \textcolor{comment}{/**}
01058 \textcolor{comment}{ * Writes one character to "stdout", which is the PC debug terminal, and returns the input}
01059 \textcolor{comment}{ * value.}
01060 \textcolor{comment}{ *}
01061 \textcolor{comment}{ * When using a wireless connection, one may need to press the spacebar before the input is}
01062 \textcolor{comment}{ * visible on the terminal.}
01063 \textcolor{comment}{ *}
01064 \textcolor{comment}{ * @param value the character to write (a value of type "char" can be used)}
01065 \textcolor{comment}{ * @return the character written}
01066 \textcolor{comment}{ */}
01067 \textcolor{keywordtype}{int} putchar(\textcolor{keywordtype}{int} value);
01068 \textcolor{comment}{/**}
01069 \textcolor{comment}{ * Behaves the same as the "print" function, and appends a trailing newline ("\(\backslash\)n").}
01070 \textcolor{comment}{ *}
01071 \textcolor{comment}{ * @param string the string to write}
01072 \textcolor{comment}{ * @return the number of characters written, excluding the new line}
01073 \textcolor{comment}{ */}
01074 \textcolor{keywordtype}{int} puts(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *string);
01075 
01076 \textcolor{comment}{/**}
01077 \textcolor{comment}{ * Prints the formatted string to the specified output stream.}
01078 \textcolor{comment}{ *}
01079 \textcolor{comment}{ * The specifiers supported by this minimalistic printf() function are:}
01080 \textcolor{comment}{ * * @c \(\backslash\)%d: Signed integer in base 10 (int)}
01081 \textcolor{comment}{ * * @c \(\backslash\)%u: Unsigned integer in base 10 (unsigned int)}
01082 \textcolor{comment}{ * * @c \(\backslash\)%x, @c \(\backslash\)%X: Integer in base 16 (unsigned int, int)}
01083 \textcolor{comment}{ * * @c \(\backslash\)%p: Pointer (void *, int *, ...)}
01084 \textcolor{comment}{ * * @c \(\backslash\)%c: Character (char)}
01085 \textcolor{comment}{ * * @c \(\backslash\)%s: Null-terminated string (char *)}
01086 \textcolor{comment}{ * * @c \(\backslash\)%%: Single literal percent sign}
01087 \textcolor{comment}{ * * @c \(\backslash\)%f: Floating-point number}
01088 \textcolor{comment}{ *}
01089 \textcolor{comment}{ * Specifiers can be modified with:}
01090 \textcolor{comment}{ * * @c 0: Zero-pad, instead of space-pad}
01091 \textcolor{comment}{ * * @c a.b: Make the field at least "a" characters wide. If "b" is specified for "%f", changes the}
01092 \textcolor{comment}{ *           number of digits after the decimal point}
01093 \textcolor{comment}{ * * @c -: Left-align, instead of right-align}
01094 \textcolor{comment}{ * * @c +: Always display the sign character (displays a leading "+" for positive numbers)}
01095 \textcolor{comment}{ * * @c l: Ignored for compatibility}
01096 \textcolor{comment}{ *}
01097 \textcolor{comment}{ * Invalid format specifiers, or mismatched parameters to specifiers, cause undefined behavior.}
01098 \textcolor{comment}{ * Other characters are written out verbatim. Do not use fprintf() on a VEX LCD port.}
01099 \textcolor{comment}{ * Use lcdPrint() instead.}
01100 \textcolor{comment}{ *}
01101 \textcolor{comment}{ * @param stream the stream to write (stdout, uart1, or uart2)}
01102 \textcolor{comment}{ * @param formatString the format string as specified above}
01103 \textcolor{comment}{ * @return the number of characters written}
01104 \textcolor{comment}{ */}
01105 \textcolor{keywordtype}{int} fprintf(PROS_FILE *stream, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *formatString, ...);
01106 \textcolor{comment}{/**}
01107 \textcolor{comment}{ * Prints the formatted string to the debug stream (the PC terminal).}
01108 \textcolor{comment}{ *}
01109 \textcolor{comment}{ * @param formatString the format string as specified in fprintf()}
01110 \textcolor{comment}{ * @return the number of characters written}
01111 \textcolor{comment}{ */}
01112 \textcolor{keywordtype}{int} printf(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *formatString, ...);
01113 \textcolor{comment}{/**}
01114 \textcolor{comment}{ * Prints the formatted string to the string buffer with the specified length limit.}
01115 \textcolor{comment}{ *}
01116 \textcolor{comment}{ * The length limit, as per the C standard, includes the trailing null character, so an}
01117 \textcolor{comment}{ * argument of 256 will cause a maximum of 255 non-null characters to be printed, and one null}
01118 \textcolor{comment}{ * terminator in all cases.}
01119 \textcolor{comment}{ *}
01120 \textcolor{comment}{ * @param buffer the string buffer where characters can be placed}
01121 \textcolor{comment}{ * @param limit the maximum number of characters to write}
01122 \textcolor{comment}{ * @param formatString the format string as specified in fprintf()}
01123 \textcolor{comment}{ * @return the number of characters stored}
01124 \textcolor{comment}{ */}
01125 \textcolor{keywordtype}{int} snprintf(\textcolor{keywordtype}{char} *buffer, size\_t limit, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *formatString, ...);
01126 \textcolor{comment}{/**}
01127 \textcolor{comment}{ * Prints the formatted string to the string buffer.}
01128 \textcolor{comment}{ *}
01129 \textcolor{comment}{ * If the buffer is not big enough to contain the complete formatted output, undefined behavior}
01130 \textcolor{comment}{ * occurs. See snprintf() for a safer version of this function.}
01131 \textcolor{comment}{ *}
01132 \textcolor{comment}{ * @param buffer the string buffer where characters can be placed}
01133 \textcolor{comment}{ * @param formatString the format string as specified in fprintf()}
01134 \textcolor{comment}{ * @return the number of characters stored}
01135 \textcolor{comment}{ */}
01136 \textcolor{keywordtype}{int} sprintf(\textcolor{keywordtype}{char} *buffer, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *formatString, ...);
01137 
01138 \textcolor{comment}{/**}
01139 \textcolor{comment}{ * LEFT button on LCD for use with lcdReadButtons()}
01140 \textcolor{comment}{ */}
01141 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LCD\_BTN\_LEFT} 1
01142 \textcolor{comment}{/**}
01143 \textcolor{comment}{ * CENTER button on LCD for use with lcdReadButtons()}
01144 \textcolor{comment}{ */}
01145 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LCD\_BTN\_CENTER} 2
01146 \textcolor{comment}{/**}
01147 \textcolor{comment}{ * RIGHT button on LCD for use with lcdReadButtons()}
01148 \textcolor{comment}{ */}
01149 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LCD\_BTN\_RIGHT} 4
01150 
01151 \textcolor{comment}{/**}
01152 \textcolor{comment}{ * Clears the LCD screen on the specified port.}
01153 \textcolor{comment}{ *}
01154 \textcolor{comment}{ * Printing to a line implicitly overwrites the contents, so clearing should only be required}
01155 \textcolor{comment}{ * at startup.}
01156 \textcolor{comment}{ *}
01157 \textcolor{comment}{ * @param lcdPort the LCD to clear, either uart1 or uart2}
01158 \textcolor{comment}{ */}
01159 \textcolor{keywordtype}{void} lcdClear(PROS_FILE *lcdPort);
01160 \textcolor{comment}{/**}
01161 \textcolor{comment}{ * Initializes the LCD port, but does not change the text or settings.}
01162 \textcolor{comment}{ *}
01163 \textcolor{comment}{ * If the LCD was not initialized before, the text currently on the screen will be undefined.}
01164 \textcolor{comment}{ * The port will not be usable with standard serial port functions until the LCD is stopped.}
01165 \textcolor{comment}{ *}
01166 \textcolor{comment}{ * @param lcdPort the LCD to initialize, either uart1 or uart2}
01167 \textcolor{comment}{ */}
01168 \textcolor{keywordtype}{void} lcdInit(PROS_FILE *lcdPort);
01169 \textcolor{comment}{/**}
01170 \textcolor{comment}{ * Prints the formatted string to the attached LCD.}
01171 \textcolor{comment}{ *}
01172 \textcolor{comment}{ * The output string will be truncated as necessary to fit on the LCD screen, 16 characters}
01173 \textcolor{comment}{ * wide. It is probably better to generate the string in a local buffer and use lcdSetText()}
01174 \textcolor{comment}{ * but this method is provided for convenience.}
01175 \textcolor{comment}{ *}
01176 \textcolor{comment}{ * @param lcdPort the LCD to write, either uart1 or uart2}
01177 \textcolor{comment}{ * @param line the LCD line to write, either 1 or 2}
01178 \textcolor{comment}{ * @param formatString the format string as specified in fprintf()}
01179 \textcolor{comment}{ */}
01180 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{DOXYGEN}
01181 \textcolor{keywordtype}{void} lcdPrint(PROS\_FILE *lcdPort, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} line, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *formatString, ...);
01182 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
01183 \textcolor{keywordtype}{void} \textcolor{keyword}{\_\_attribute\_\_} ((format (printf, 3, 4))) lcdPrint(PROS_FILE *lcdPort, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} line,
01184        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *formatString, ...);
01185 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
01186 \textcolor{comment}{/**}
01187 \textcolor{comment}{ * Reads the user button status from the LCD display.}
01188 \textcolor{comment}{ *}
01189 \textcolor{comment}{ * For example, if the left and right buttons are pushed, (1 | 4) = 5 will be returned. 0 is}
01190 \textcolor{comment}{ * returned if no buttons are pushed.}
01191 \textcolor{comment}{ *}
01192 \textcolor{comment}{ * @param lcdPort the LCD to poll, either uart1 or uart2}
01193 \textcolor{comment}{ * @return the buttons pressed as a bit mask}
01194 \textcolor{comment}{ */}
01195 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lcdReadButtons(PROS_FILE *lcdPort);
01196 \textcolor{comment}{/**}
01197 \textcolor{comment}{ * Sets the specified LCD backlight to be on or off.}
01198 \textcolor{comment}{ *}
01199 \textcolor{comment}{ * Turning it off will save power but may make it more difficult to read in dim conditions.}
01200 \textcolor{comment}{ *}
01201 \textcolor{comment}{ * @param lcdPort the LCD to adjust, either uart1 or uart2}
01202 \textcolor{comment}{ * @param backlight true to turn the backlight on, or false to turn it off}
01203 \textcolor{comment}{ */}
01204 \textcolor{keywordtype}{void} lcdSetBacklight(PROS_FILE *lcdPort, \textcolor{keywordtype}{bool} backlight);
01205 \textcolor{comment}{/**}
01206 \textcolor{comment}{ * Prints the string buffer to the attached LCD.}
01207 \textcolor{comment}{ *}
01208 \textcolor{comment}{ * The output string will be truncated as necessary to fit on the LCD screen, 16 characters}
01209 \textcolor{comment}{ * wide. This function, like fprint(), is much, much faster than a formatted routine such as}
01210 \textcolor{comment}{ * lcdPrint() and consumes less memory.}
01211 \textcolor{comment}{ *}
01212 \textcolor{comment}{ * @param lcdPort the LCD to write, either uart1 or uart2}
01213 \textcolor{comment}{ * @param line the LCD line to write, either 1 or 2}
01214 \textcolor{comment}{ * @param buffer the string to write}
01215 \textcolor{comment}{ */}
01216 \textcolor{keywordtype}{void} lcdSetText(PROS_FILE *lcdPort, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} line, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *buffer);
01217 \textcolor{comment}{/**}
01218 \textcolor{comment}{ * Shut down the specified LCD port.}
01219 \textcolor{comment}{ *}
01220 \textcolor{comment}{ * @param lcdPort the LCD to stop, either uart1 or uart2}
01221 \textcolor{comment}{ */}
01222 \textcolor{keywordtype}{void} lcdShutdown(PROS_FILE *lcdPort);
01223 
01224 \textcolor{comment}{// -------------------- Real-time scheduler functions --------------------}
01225 \textcolor{comment}{/**}
01226 \textcolor{comment}{ * Only this many tasks can exist at once. Attempts to create further tasks will not succeed}
01227 \textcolor{comment}{ * until tasks end or are destroyed, AND the idle task cleans them up.}
01228 \textcolor{comment}{ *}
01229 \textcolor{comment}{ * Changing this value will not change the limit without a kernel recompile. The idle task}
01230 \textcolor{comment}{ * and VEX daemon task count against the limit. The user autonomous() or teleop() also counts}
01231 \textcolor{comment}{ * against the limit, so 12 tasks usually remain for other uses.}
01232 \textcolor{comment}{ */}
01233 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_MAX} 16
01234 \textcolor{comment}{/**}
01235 \textcolor{comment}{ * The maximum number of available task priorities, which run from 0 to 5.}
01236 \textcolor{comment}{ *}
01237 \textcolor{comment}{ * Changing this value will not change the priority count without a kernel recompile.}
01238 \textcolor{comment}{ */}
01239 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_MAX\_PRIORITIES} 6
01240 \textcolor{comment}{/**}
01241 \textcolor{comment}{ * The lowest priority that can be assigned to a task, which puts it on a level with the idle}
01242 \textcolor{comment}{ * task. This may cause severe performance problems and is generally not recommended.}
01243 \textcolor{comment}{ */}
01244 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_PRIORITY\_LOWEST} 0
01245 \textcolor{comment}{/**}
01246 \textcolor{comment}{ * The default task priority, which should be used for most tasks.}
01247 \textcolor{comment}{ *}
01248 \textcolor{comment}{ * Default tasks such as autonomous() inherit this priority.}
01249 \textcolor{comment}{ */}
01250 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_PRIORITY\_DEFAULT} 2
01251 \textcolor{comment}{/**}
01252 \textcolor{comment}{ * The highest priority that can be assigned to a task. Unlike the lowest priority, this}
01253 \textcolor{comment}{ * priority can be safely used without hampering interrupts. Beware of deadlock.}
01254 \textcolor{comment}{ */}
01255 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_PRIORITY\_HIGHEST} \textcolor{preprocessor}{(}TASK_MAX_PRIORITIES \textcolor{preprocessor}{-} 1\textcolor{preprocessor}{)}
01256 \textcolor{comment}{/**}
01257 \textcolor{comment}{ * The recommended stack size for a new task that does an average amount of work. This stack}
01258 \textcolor{comment}{ * size is used for default tasks such as autonomous().}
01259 \textcolor{comment}{ *}
01260 \textcolor{comment}{ * This is probably OK for 4-5 levels of function calls and the use of printf() with several}
01261 \textcolor{comment}{ * arguments. Tasks requiring deep recursion or large local buffers will need a bigger stack.}
01262 \textcolor{comment}{ */}
01263 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_DEFAULT\_STACK\_SIZE} 512
01264 \textcolor{comment}{/**}
01265 \textcolor{comment}{ * The minimum stack depth for a task. Scheduler state is stored on the stack, so even if the}
01266 \textcolor{comment}{ * task never uses the stack, at least this much space must be allocated.}
01267 \textcolor{comment}{ *}
01268 \textcolor{comment}{ * Function calls and other seemingly innocent constructs may place information on the stack.}
01269 \textcolor{comment}{ * Err on the side of a larger stack when possible.}
01270 \textcolor{comment}{ */}
01271 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_MINIMAL\_STACK\_SIZE}    64
01272 
01273 \textcolor{comment}{/**}
01274 \textcolor{comment}{ * Constant returned from taskGetState() when the task is dead or nonexistant.}
01275 \textcolor{comment}{ */}
01276 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_DEAD} 0
01277 \textcolor{comment}{/**}
01278 \textcolor{comment}{ * Constant returned from taskGetState() when the task is actively executing.}
01279 \textcolor{comment}{ */}
01280 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_RUNNING} 1
01281 \textcolor{comment}{/**}
01282 \textcolor{comment}{ * Constant returned from taskGetState() when the task is exists and is available to run, but}
01283 \textcolor{comment}{ * not currently running.}
01284 \textcolor{comment}{ */}
01285 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_RUNNABLE} 2
01286 \textcolor{comment}{/**}
01287 \textcolor{comment}{ * Constant returned from taskGetState() when the task is delayed or blocked waiting for a}
01288 \textcolor{comment}{ * semaphore, mutex, or I/O operation.}
01289 \textcolor{comment}{ */}
01290 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_SLEEPING} 3
01291 \textcolor{comment}{/**}
01292 \textcolor{comment}{ * Constant returned from taskGetState() when the task is suspended using taskSuspend().}
01293 \textcolor{comment}{ */}
01294 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{TASK\_SUSPENDED} 4
01295 
01296 \textcolor{comment}{/**}
01297 \textcolor{comment}{ * Type by which tasks are referenced.}
01298 \textcolor{comment}{ *}
01299 \textcolor{comment}{ * As this is a pointer type, it can be safely passed or stored by value.}
01300 \textcolor{comment}{ */}
01301 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} * TaskHandle;
01302 \textcolor{comment}{/**}
01303 \textcolor{comment}{ * Type by which mutexes are referenced.}
01304 \textcolor{comment}{ *}
01305 \textcolor{comment}{ * As this is a pointer type, it can be safely passed or stored by value.}
01306 \textcolor{comment}{ */}
01307 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} * Mutex;
01308 \textcolor{comment}{/**}
01309 \textcolor{comment}{ * Type by which semaphores are referenced.}
01310 \textcolor{comment}{ *}
01311 \textcolor{comment}{ * As this is a pointer type, it can be safely passed or stored by value.}
01312 \textcolor{comment}{ */}
01313 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} * Semaphore;
01314 \textcolor{comment}{/**}
01315 \textcolor{comment}{ * Type for defining task functions. Task functions must accept one parameter of type}
01316 \textcolor{comment}{ * "void *"; they need not use it.}
01317 \textcolor{comment}{ *}
01318 \textcolor{comment}{ * For example:}
01319 \textcolor{comment}{ *}
01320 \textcolor{comment}{ * void MyTask(void *ignore) \{}
01321 \textcolor{comment}{ *     while (1);}
01322 \textcolor{comment}{ * \}}
01323 \textcolor{comment}{ */}
01324 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} (*TaskCode)(\textcolor{keywordtype}{void} *);
01325 
01326 \textcolor{comment}{/**}
01327 \textcolor{comment}{ * Creates a new task and add it to the list of tasks that are ready to run.}
01328 \textcolor{comment}{ *}
01329 \textcolor{comment}{ * @param taskCode the function to execute in its own task}
01330 \textcolor{comment}{ * @param stackDepth the number of variables available on the stack (4 * stackDepth bytes will}
01331 \textcolor{comment}{ * be allocated on the Cortex)}
01332 \textcolor{comment}{ * @param parameters an argument passed to the taskCode function}
01333 \textcolor{comment}{ * @param priority a value from TASK\_PRIORITY\_LOWEST to TASK\_PRIORITY\_HIGHEST determining the}
01334 \textcolor{comment}{ * initial priority of the task}
01335 \textcolor{comment}{ * @return a handle to the created task, or NULL if an error occurred}
01336 \textcolor{comment}{ */}
01337 TaskHandle taskCreate(TaskCode taskCode, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} stackDepth, \textcolor{keywordtype}{void} *parameters,
01338        \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} priority);
01339 \textcolor{comment}{/**}
01340 \textcolor{comment}{ * Delays the current task for a given number of milliseconds.}
01341 \textcolor{comment}{ *}
01342 \textcolor{comment}{ * Delaying for a period of zero will force a reschedule, where tasks of equal priority may be}
01343 \textcolor{comment}{ * scheduled if available. The calling task will still be available for immediate rescheduling}
01344 \textcolor{comment}{ * once the other tasks have had their turn or if nothing of equal or higher priority is}
01345 \textcolor{comment}{ * available to be scheduled.}
01346 \textcolor{comment}{ *}
01347 \textcolor{comment}{ * This is not the best method to have a task execute code at predefined intervals, as the}
01348 \textcolor{comment}{ * delay time is measured from when the delay is requested. To delay cyclically, use}
01349 \textcolor{comment}{ * taskDelayUntil().}
01350 \textcolor{comment}{ *}
01351 \textcolor{comment}{ * @param msToDelay the number of milliseconds to wait, with 1000 milliseconds per second}
01352 \textcolor{comment}{ */}
01353 \textcolor{keywordtype}{void} taskDelay(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} msToDelay);
01354 \textcolor{comment}{/**}
01355 \textcolor{comment}{ * Delays the current task until a specified time. The task will be unblocked}
01356 \textcolor{comment}{ * at the time *previousWakeTime + cycleTime, and *previousWakeTime will be changed to reflect}
01357 \textcolor{comment}{ * the time at which the task will unblock.}
01358 \textcolor{comment}{ *}
01359 \textcolor{comment}{ * If the target time is in the past, no delay occurs, but a reschedule is forced, as if}
01360 \textcolor{comment}{ * taskDelay() was called with an argument of zero. If the sum of cycleTime and}
01361 \textcolor{comment}{ * *previousWakeTime overflows or underflows, undefined behavior occurs.}
01362 \textcolor{comment}{ *}
01363 \textcolor{comment}{ * This function should be used by cyclical tasks to ensure a constant execution frequency.}
01364 \textcolor{comment}{ * While taskDelay() specifies a wake time relative to the time at which the function is}
01365 \textcolor{comment}{ * called, taskDelayUntil() specifies the absolute future time at which it wishes to unblock.}
01366 \textcolor{comment}{ * Calling taskDelayUntil with the same cycleTime parameter value in a loop, with}
01367 \textcolor{comment}{ * previousWakeTime referring to a local variable initialized to millis(), will cause the}
01368 \textcolor{comment}{ * loop to execute with a fixed period.}
01369 \textcolor{comment}{ *}
01370 \textcolor{comment}{ * @param previousWakeTime a pointer to the location storing the last unblock time, obtained}
01371 \textcolor{comment}{ * by using the "&" operator on a variable (e.g. "taskDelayUntil(&now, 50);")}
01372 \textcolor{comment}{ * @param cycleTime the number of milliseconds to wait, with 1000 milliseconds per second}
01373 \textcolor{comment}{ */}
01374 \textcolor{keywordtype}{void} taskDelayUntil(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *previousWakeTime, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} cycleTime);
01375 \textcolor{comment}{/**}
01376 \textcolor{comment}{ * Kills and removes the specified task from the kernel task list.}
01377 \textcolor{comment}{ *}
01378 \textcolor{comment}{ * Deleting the last task will end the program, possibly leading to undesirable states as}
01379 \textcolor{comment}{ * some outputs may remain in their last set configuration.}
01380 \textcolor{comment}{ *}
01381 \textcolor{comment}{ * NOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that}
01382 \textcolor{comment}{ * have been deleted. It is therefore important that the idle task is not starved of}
01383 \textcolor{comment}{ * processing time. Memory allocated by the task code is not automatically freed, and should be}
01384 \textcolor{comment}{ * freed before the task is deleted.}
01385 \textcolor{comment}{ *}
01386 \textcolor{comment}{ * @param taskToDelete the task to kill; passing NULL kills the current task}
01387 \textcolor{comment}{ */}
01388 \textcolor{keywordtype}{void} taskDelete(TaskHandle taskToDelete);
01389 \textcolor{comment}{/**}
01390 \textcolor{comment}{ * Determines the number of tasks that are currently being managed.}
01391 \textcolor{comment}{ *}
01392 \textcolor{comment}{ * This includes all ready, blocked and suspended tasks. A task that has been deleted but not}
01393 \textcolor{comment}{ * yet freed by the idle task will also be included in the count. Tasks recently created may}
01394 \textcolor{comment}{ * take one context switch to be counted.}
01395 \textcolor{comment}{ *}
01396 \textcolor{comment}{ * @return the number of tasks that are currently running, waiting, or suspended}
01397 \textcolor{comment}{ */}
01398 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} taskGetCount();
01399 \textcolor{comment}{/**}
01400 \textcolor{comment}{ * Retrieves the state of the specified task. Note that the state of tasks which have died may}
01401 \textcolor{comment}{ * be re-used for future tasks, causing the value returned by this function to reflect a}
01402 \textcolor{comment}{ * different task than possibly intended in this case.}
01403 \textcolor{comment}{ *}
01404 \textcolor{comment}{ * @param task Handle to the task to query. Passing NULL will query the current task status}
01405 \textcolor{comment}{ * (which will, by definition, be TASK\_RUNNING if this call returns)}
01406 \textcolor{comment}{ *}
01407 \textcolor{comment}{ * @return A value reflecting the task's status, one of the constants TASK\_DEAD, TASK\_RUNNING,}
01408 \textcolor{comment}{ * TASK\_RUNNABLE, TASK\_SLEEPING, or TASK\_SUSPENDED}
01409 \textcolor{comment}{ */}
01410 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} taskGetState(TaskHandle task);
01411 \textcolor{comment}{/**}
01412 \textcolor{comment}{ * Obtains the priority of the specified task.}
01413 \textcolor{comment}{ *}
01414 \textcolor{comment}{ * @param task the task to check; passing NULL checks the current task}
01415 \textcolor{comment}{ * @return the priority of that task from 0 to TASK\_MAX\_PRIORITIES}
01416 \textcolor{comment}{ */}
01417 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} taskPriorityGet(\textcolor{keyword}{const} TaskHandle task);
01418 \textcolor{comment}{/**}
01419 \textcolor{comment}{ * Sets the priority of the specified task.}
01420 \textcolor{comment}{ *}
01421 \textcolor{comment}{ * A context switch may occur before the function returns if the priority being set is higher}
01422 \textcolor{comment}{ * than the currently executing task and the task being mutated is available to be scheduled.}
01423 \textcolor{comment}{ *}
01424 \textcolor{comment}{ * @param task the task to change; passing NULL changes the current task}
01425 \textcolor{comment}{ * @param newPriority a value between TASK\_PRIORITY\_LOWEST and TASK\_PRIORITY\_HIGHEST inclusive}
01426 \textcolor{comment}{ * indicating the new task priority}
01427 \textcolor{comment}{ */}
01428 \textcolor{keywordtype}{void} taskPrioritySet(TaskHandle task, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} newPriority);
01429 \textcolor{comment}{/**}
01430 \textcolor{comment}{ * Resumes the specified task.}
01431 \textcolor{comment}{ *}
01432 \textcolor{comment}{ * A task that has been suspended by one or more calls to taskSuspend() will be made available}
01433 \textcolor{comment}{ * for scheduling again by a call to taskResume(). If the task was not suspended at the time}
01434 \textcolor{comment}{ * of the call to taskResume(), undefined behavior occurs.}
01435 \textcolor{comment}{ *}
01436 \textcolor{comment}{ * @param taskToResume the task to change; passing NULL is not allowed as the current task}
01437 \textcolor{comment}{ * cannot be suspended (it is obviously running if this function is called)}
01438 \textcolor{comment}{ */}
01439 \textcolor{keywordtype}{void} taskResume(TaskHandle taskToResume);
01440 \textcolor{comment}{/**}
01441 \textcolor{comment}{ * Starts a task which will periodically call the specified function.}
01442 \textcolor{comment}{ *}
01443 \textcolor{comment}{ * Intended for use as a quick-start skeleton for cyclic tasks with higher priority than the}
01444 \textcolor{comment}{ * "main" tasks. The created task will have priority TASK\_PRIORITY\_DEFAULT + 1 with the default}
01445 \textcolor{comment}{ * stack size. To customize behavior, create a task manually with the specified function.}
01446 \textcolor{comment}{ *}
01447 \textcolor{comment}{ * This task will automatically terminate after one further function invocation when the robot}
01448 \textcolor{comment}{ * is disabled or when the robot mode is switched.}
01449 \textcolor{comment}{ *}
01450 \textcolor{comment}{ * @param fn the function to call in this loop}
01451 \textcolor{comment}{ * @param increment the delay between successive calls in milliseconds; the taskDelayUntil()}
01452 \textcolor{comment}{ * function is used for accurate cycle timing}
01453 \textcolor{comment}{ * @return a handle to the task, or NULL if an error occurred}
01454 \textcolor{comment}{ */}
01455 TaskHandle taskRunLoop(\textcolor{keywordtype}{void} (*fn)(\textcolor{keywordtype}{void}), \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} increment);
01456 \textcolor{comment}{/**}
01457 \textcolor{comment}{ * Suspends the specified task.}
01458 \textcolor{comment}{ *}
01459 \textcolor{comment}{ * When suspended a task will not be scheduled, regardless of whether it might be otherwise}
01460 \textcolor{comment}{ * available to run.}
01461 \textcolor{comment}{ *}
01462 \textcolor{comment}{ * @param taskToSuspend the task to suspend; passing NULL suspends the current task}
01463 \textcolor{comment}{ */}
01464 \textcolor{keywordtype}{void} taskSuspend(TaskHandle taskToSuspend);
01465 
01466 \textcolor{comment}{/**}
01467 \textcolor{comment}{ * Creates a semaphore intended for synchronizing tasks. To prevent some critical code from}
01468 \textcolor{comment}{ * simultaneously modifying a shared resource, use mutexes instead.}
01469 \textcolor{comment}{ *}
01470 \textcolor{comment}{ * Semaphores created using this function can be accessed using the semaphoreTake() and}
01471 \textcolor{comment}{ * semaphoreGive() functions. The mutex functions must not be used on objects of this type.}
01472 \textcolor{comment}{ *}
01473 \textcolor{comment}{ * This type of object does not need to have balanced take and give calls, so priority}
01474 \textcolor{comment}{ * inheritance is not used. Semaphores can be signalled by an interrupt routine.}
01475 \textcolor{comment}{ *}
01476 \textcolor{comment}{ * @return a handle to the created semaphore}
01477 \textcolor{comment}{ */}
01478 Semaphore semaphoreCreate();
01479 \textcolor{comment}{/**}
01480 \textcolor{comment}{ * Signals a semaphore. Tasks waiting for a signal using semaphoreTake() will be unblocked by}
01481 \textcolor{comment}{ * this call and can continue execution.}
01482 \textcolor{comment}{ *}
01483 \textcolor{comment}{ * Slow processes can give semaphores when ready, and fast processes waiting to take the}
01484 \textcolor{comment}{ * semaphore will continue at that point.}
01485 \textcolor{comment}{ *}
01486 \textcolor{comment}{ * @param semaphore the semaphore to signal}
01487 \textcolor{comment}{ * @return true if the semaphore was successfully given, or false if the semaphore was not}
01488 \textcolor{comment}{ * taken since the last give}
01489 \textcolor{comment}{ */}
01490 \textcolor{keywordtype}{bool} semaphoreGive(Semaphore semaphore);
01491 \textcolor{comment}{/**}
01492 \textcolor{comment}{ * Waits on a semaphore. If the semaphore is already in the "taken" state, the current task}
01493 \textcolor{comment}{ * will wait for the semaphore to be signaled. Other tasks can run during this time.}
01494 \textcolor{comment}{ *}
01495 \textcolor{comment}{ * @param semaphore the semaphore to wait}
01496 \textcolor{comment}{ * @param blockTime the maximum time to wait for the semaphore to be given, where -1}
01497 \textcolor{comment}{ * specifies an infinite timeout}
01498 \textcolor{comment}{ * @return true if the semaphore was successfully taken, or false if the timeout expired}
01499 \textcolor{comment}{ */}
01500 \textcolor{keywordtype}{bool} semaphoreTake(Semaphore semaphore, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} blockTime);
01501 \textcolor{comment}{/**}
01502 \textcolor{comment}{ * Deletes the specified semaphore. This function can be dangerous; deleting semaphores being}
01503 \textcolor{comment}{ * waited on by a task may cause deadlock or a crash.}
01504 \textcolor{comment}{ *}
01505 \textcolor{comment}{ * @param semaphore the semaphore to destroy}
01506 \textcolor{comment}{ */}
01507 \textcolor{keywordtype}{void} semaphoreDelete(Semaphore semaphore);
01508 
01509 \textcolor{comment}{/**}
01510 \textcolor{comment}{ * Creates a mutex intended to allow only one task to use a resource at a time. For signalling}
01511 \textcolor{comment}{ * and synchronization, try using semaphores.}
01512 \textcolor{comment}{ *}
01513 \textcolor{comment}{ * Mutexes created using this function can be accessed using the mutexTake() and mutexGive()}
01514 \textcolor{comment}{ * functions. The semaphore functions must not be used on objects of this type.}
01515 \textcolor{comment}{ *}
01516 \textcolor{comment}{ * This type of object uses a priority inheritance mechanism so a task 'taking' a mutex MUST}
01517 \textcolor{comment}{ * ALWAYS 'give' the mutex back once the mutex is no longer required.}
01518 \textcolor{comment}{ *}
01519 \textcolor{comment}{ * @return a handle to the created mutex}
01520 \textcolor{comment}{ */}
01521 Mutex mutexCreate();
01522 \textcolor{comment}{/**}
01523 \textcolor{comment}{ * Relinquishes a mutex so that other tasks can use the resource it guards. The mutex must be}
01524 \textcolor{comment}{ * held by the current task using a corresponding call to mutexTake.}
01525 \textcolor{comment}{ *}
01526 \textcolor{comment}{ * @param mutex the mutex to release}
01527 \textcolor{comment}{ * @return true if the mutex was released, or false if the mutex was not already held}
01528 \textcolor{comment}{ */}
01529 \textcolor{keywordtype}{bool} mutexGive(Mutex mutex);
01530 \textcolor{comment}{/**}
01531 \textcolor{comment}{ * Requests a mutex so that other tasks cannot simultaneously use the resource it guards.}
01532 \textcolor{comment}{ * The mutex must not already be held by the current task. If another task already}
01533 \textcolor{comment}{ * holds the mutex, the function will wait for the mutex to be released. Other tasks can run}
01534 \textcolor{comment}{ * during this time.}
01535 \textcolor{comment}{ *}
01536 \textcolor{comment}{ * @param mutex the mutex to request}
01537 \textcolor{comment}{ * @param blockTime the maximum time to wait for the mutex to be available, where -1}
01538 \textcolor{comment}{ * specifies an infinite timeout}
01539 \textcolor{comment}{ * @return true if the mutex was successfully taken, or false if the timeout expired}
01540 \textcolor{comment}{ */}
01541 \textcolor{keywordtype}{bool} mutexTake(Mutex mutex, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} blockTime);
01542 \textcolor{comment}{/**}
01543 \textcolor{comment}{ * Deletes the specified mutex. This function can be dangerous; deleting semaphores being}
01544 \textcolor{comment}{ * waited on by a task may cause deadlock or a crash.}
01545 \textcolor{comment}{ *}
01546 \textcolor{comment}{ * @param mutex the mutex to destroy}
01547 \textcolor{comment}{ */}
01548 \textcolor{keywordtype}{void} mutexDelete(Mutex mutex);
01549 
01550 \textcolor{comment}{/**}
01551 \textcolor{comment}{ * Wiring-compatible alias of taskDelay().}
01552 \textcolor{comment}{ *}
01553 \textcolor{comment}{ * @param time the duration of the delay in milliseconds (1 000 milliseconds per second)}
01554 \textcolor{comment}{ */}
01555 \textcolor{keywordtype}{void} delay(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} time);
01556 \textcolor{comment}{/**}
01557 \textcolor{comment}{ * Wait for approximately the given number of microseconds.}
01558 \textcolor{comment}{ *}
01559 \textcolor{comment}{ * The method used for delaying this length of time may vary depending on the argument.}
01560 \textcolor{comment}{ * The current task will always be delayed by at least the specified period, but possibly much}
01561 \textcolor{comment}{ * more depending on CPU load. In general, this function is less reliable than delay(). Using}
01562 \textcolor{comment}{ * this function in a loop may hog processing time from other tasks.}
01563 \textcolor{comment}{ *}
01564 \textcolor{comment}{ * @param us the duration of the delay in microseconds (1 000 000 microseconds per second)}
01565 \textcolor{comment}{ */}
01566 \textcolor{keywordtype}{void} delayMicroseconds(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} us);
01567 \textcolor{comment}{/**}
01568 \textcolor{comment}{ * Returns the number of microseconds since Cortex power-up. There are 10^6 microseconds in a}
01569 \textcolor{comment}{ * second, so as a 32-bit integer, this will overflow and wrap back to zero every two hours or}
01570 \textcolor{comment}{ * so.}
01571 \textcolor{comment}{ *}
01572 \textcolor{comment}{ * This function is Wiring-compatible.}
01573 \textcolor{comment}{ *}
01574 \textcolor{comment}{ * @return the number of microseconds since the Cortex was turned on or the last overflow}
01575 \textcolor{comment}{ */}
01576 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} micros();
01577 \textcolor{comment}{/**}
01578 \textcolor{comment}{ * Returns the number of milliseconds since Cortex power-up. There are 1000 milliseconds in a}
01579 \textcolor{comment}{ * second, so as a 32-bit integer, this will not overflow for 50 days.}
01580 \textcolor{comment}{ *}
01581 \textcolor{comment}{ * This function is Wiring-compatible.}
01582 \textcolor{comment}{ *}
01583 \textcolor{comment}{ * @return the number of milliseconds since the Cortex was turned on}
01584 \textcolor{comment}{ */}
01585 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} millis();
01586 \textcolor{comment}{/**}
01587 \textcolor{comment}{ * Alias of taskDelay() intended to help EasyC users.}
01588 \textcolor{comment}{ *}
01589 \textcolor{comment}{ * @param time the duration of the delay in milliseconds (1 000 milliseconds per second)}
01590 \textcolor{comment}{ */}
01591 \textcolor{keywordtype}{void} wait(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} time);
01592 \textcolor{comment}{/**}
01593 \textcolor{comment}{ * Alias of taskDelayUntil() intended to help EasyC users.}
01594 \textcolor{comment}{ *}
01595 \textcolor{comment}{ * @param previousWakeTime a pointer to the last wakeup time}
01596 \textcolor{comment}{ * @param time the duration of the delay in milliseconds (1 000 milliseconds per second)}
01597 \textcolor{comment}{ */}
01598 \textcolor{keywordtype}{void} waitUntil(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *previousWakeTime, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} time);
01599 \textcolor{comment}{/**}
01600 \textcolor{comment}{ * Enables IWDG watchdog timer which will reset the cortex if it locks up due to static shock}
01601 \textcolor{comment}{ * or a misbehaving task preventing the timer to be reset. Not recovering from static shock}
01602 \textcolor{comment}{ * will cause the robot to continue moving its motors indefinitely until turned off manually.}
01603 \textcolor{comment}{ *}
01604 \textcolor{comment}{ * This function should only be called once in initializeIO()}
01605 \textcolor{comment}{ */}
01606 \textcolor{keywordtype}{void} watchdogInit();
01607 \textcolor{comment}{/**}
01608 \textcolor{comment}{ * Enables the Cortex to run the op control task in a standalone mode- no VEXnet connection required.}
01609 \textcolor{comment}{ *}
01610 \textcolor{comment}{ * This function should only be called once in initializeIO()}
01611 \textcolor{comment}{ */}
01612 \textcolor{keywordtype}{void} standaloneModeEnable();
01613 
01614 \textcolor{comment}{// End C++ extern to C}
01615 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \_\_cplusplus
01616 \}
01617 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
01618 
01619 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
\end{DoxyCode}
